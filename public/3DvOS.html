<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>vOS Demo</title>
	<link rel="stylesheet" href="css/jquery-ui.css" type="text/css">
	<link rel="stylesheet" href="css/buttons.css" type="text/css" media="screen" title="no title" charset="utf-8">
	<link rel="stylesheet" href="css/osv.css" type="text/css" media="screen" title="no title" charset="utf-8">

	<script type="text/javascript" src="js/three.min.js"></script>
	<script type="text/javascript" src="js/jquery-1.8.2.min.js"></script>
	<script type="text/javascript" src="js/jquery-ui.min.js"></script>
	<script type="text/javascript" src="js/jquery.base64.min.js"></script>
	<script type="text/javascript" src="js/OculusRiftEffect.js"></script>
	<script type="text/javascript" src="js/RequestAnimationFrame.js"></script>
	<script type="text/javascript" src="js/vr.js"></script>
	<script src="http://162.222.183.103/socket.io/socket.io.js"></script>
	<script src="utility.js"></script>
	<script src="applist.js"></script>
	<script src="VRK.js"></script>
</head>
<body>
<div id="code"></div>
<div id="viewer"></div>
<script>

var camera_start = {
	x: Math.PI/2,
	y: -200,
	z: 10
};

var connect_code = '';

var Point = function(x, y, i) {
	this.start = {
		x: x,
		y: y
	}
	this.x = x;
	this.y = y;
	this.i = i;
	this.taken = false;
	this.onRelease_callback = function() {};
	this.release = function(x, y, i) {
		this.onRelease_callback(x, y, i);
	};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y, i) {};
	this.move = function(x, y, i) {
		this.x = x;
		this.y = y;
		this.onMove_callback(x, y, i);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	}
};

var kM = {
	apps: [],
	front: null,
	back: null,
	front_and_back: null,
	points: []
};

kM.topBar = new VRK.SystemBar(0, 8 + 1/2, 12, 1);

//keyboard is an 8 x 12 grid
VRK.Keyboard = function() {
	this.objects = [kM.topBar];
	this.add = function(object){
		this.objects.push(object);
	};
	this.set = function(array){
		this.objects = array;
		this.objects.push(kM.topBar);
	};
};

var apps = appList;

var WIDTH = 1200,
  HEIGHT = 800;

WIDTH = window.innerWidth; 
HEIGHT = window.innerHeight;


var VIEW_ANGLE = 60,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 10000;

//var ambientLight =
//  new THREE.AmbientLight(0xCC0000);

var checkGrab = function(point) {
	var keyboardApp = kM.getKeyboardApp();
	if (!kM.topBar.moving) {
		var objects = [];
		switch(kM.state) {
			case kM.State.Normal:
				objects = keyboardApp.keyboard.objects;
				break;
			case kM.State.AppSwitch:
				objects = kM.appSwitcherKeyboard.objects;
				break;
			case kM.State.Notifications:
				objects = kM.notificationKeyboard.objects;
				break;
		}
		objects.map(function(object) {
			if (object.available && object.contains(point.x, point.y)) {
				object.registerPoint(point);
				point.taken = true;
			}
		});
	}
	if (kM.hidden && kM.topBar.available && !point.taken) {
		kM.topBar.registerPoint(point);
		point.taken = true;
	}
}

kM.State = {
	Normal: 'normal',
	AppSwitch: 'app-switch',
	Notifications: 'notifications'
};
kM.notificationKeyboard = new VRK.Keyboard();
kM.appSwitcherKeyboard = new VRK.Keyboard();

var setUpNotifications = function() {
	kM.appSwitcherKeyboard.objects = [kM.topBar];
};
setUpNotifications();

var setUpAppSwitcher = function() {
	kM.appSwitcherKeyboard.objects = [kM.topBar];
	var row = 0;
	var column = 0;
	var index = 0;
	var app;

	var codeLabel = new VRK.Label(3, 7, 2, 1, 'Code:  ' + connect_code, 15);
	kM.appSwitcherKeyboard.add(codeLabel);
	for (var i = 0; i < kM.apps.length; i++) {
		app = kM.apps[i];
		
		var icon = new VRK.Button(2 + row * 2, 6 - 2 * column, 1, 1, ' '+i, 15, app.icon);
		icon.onClick((function(index){
			return function(){
				kM.open(kM.apps[index]);
			};
		})(i));
		kM.appSwitcherKeyboard.add(icon);
		if (row >= 4) {
			row = 0;
			column++;
		} else {
			row++;
		}
	}
};
setUpAppSwitcher();

kM.state = kM.State.AppSwitch;

var socket = io.connect('http://162.222.183.103/');
socket.emit('declare-type', 'output');

var device_width = WIDTH;
var device_height = HEIGHT;

socket.on('size', function (data) {
	device_width = JSON.parse(data).width;
	device_height = JSON.parse(data).height;
});

socket.on('code', function (code) {
	connect_code = code;
	setUpAppSwitcher();
	screen_code = document.getElementById( 'code' );
	screen_code.innerText = 'Use this code to connect: ' + code;
});

socket.on('start', function (data) {
	var parsed = JSON.parse(data);
	var point = new Point(parsed.x, parsed.y, parsed.i);
	kM.points[parsed.i] = point;
	checkGrab(point);
});

socket.on('move', function (data) {
	var parsed = JSON.parse(data);
	var point = kM.points[parsed.i];
	point.move(parsed.x, parsed.y, parsed.i);
	if (!point.taken) {
		checkGrab(point);
	}
});

socket.on('end', function (data) {
	var parsed = JSON.parse(data);
	kM.points[parsed.i].release(parsed.x, parsed.y, parsed.i);
	kM.points[parsed.i] = {};
});

kM.open = function(app) {
	if (app.external.drawFront != null) {
		//if front and back app has back, push to back
		if (kM.front_and_back != null && kM.front_and_back.external.drawBack != null) {
			kM.back = kM.front_and_back;
		}
		kM.front_and_back = null;
		kM.front = app;
	} else if(app.external.drawFrontAndBack) {
		kM.front = null;
		kM.back = null;
		kM.front_and_back = app;
	} else if(app.external.drawBack) {
		kM.front_and_back = null;
		kM.back = app;
	}
	kM.state = kM.State.Normal;
};

kM.add = function(extern) {
	var app = {};
	app.external = extern;
	app.keyboard = new VRK.Keyboard(app);
	app.name = extern.name;
	app.icon = extern.icon;
	kM.apps.push(app);
	app.external.setUpKeyboard(app.keyboard);
	//kM.open(app);
};

kM.canMaximize = function() {
	return kM.front != null && kM.front.external.drawFrontAndBack != null;
};

kM.canMinimize = function() {
	return kM.front_and_back != null && kM.front_and_back.external.drawFront != null;
};

kM.getKeyboardApp = function() {
	if (kM.front != null) {
		return kM.front;
	} else if (kM.front_and_back != null) {
		return kM.front_and_back;
	} 
	return null;
}

kM.minimize = function() {
	if (kM.canMinimize()) {
		kM.front = kM.front_and_back;
		kM.front_and_back = null;
	}
};

kM.maximize = function() {
	if (kM.canMaximize()) {
		kM.front_and_back = kM.front;
		kM.front = null;
		kM.back = null;
	}
};

kM.toggleMaxMin = function() {
	if (kM.front != null) {
		kM.maximize();
	} else if(kM.front_and_back != null) {
		kM.minimize();
	}
};

kM.close = function() {
	if (kM.front != null) {
		if (kM.back != null && kM.back.external.drawFrontAndBack != null) {
			kM.front_and_back = kM.back;
			kM.back = null;
		}
		kM.front = null;
	} else if (kM.front_and_back != null) {
		kM.front_and_back = null;
	} else if (kM.back != null) {
		kM.back = null;
	}
	if (kM.front == null && kM.front_and_back == null) {
		kM.state = kM.State.AppSwitch;
	}
}


/*

Apps can have any set of the three functions f, b, f_b

New apps open at f, if no f, go to fb, if no fb, go to b. Doesn't depend on existing apps.
If existing app conflicts, close, unless was at fb, then go to b if doesn't conflict.

Only can control with keyboard in f and f_b. Maximize and minimize goes between them. App can control this. If you maximize and then minimize, it closes any background app.

Only way to get background app if to be in f_b and open a new f.

=> If you have a b, you must have an fb.

*/

var oldState = kM.State.Normal;

kM.drawKeyboard = function(scene) {
	var redLambert = new THREE.MeshBasicMaterial({ color: 0xCC0000 });

	var board = new THREE.Mesh(
		new THREE.PlaneGeometry(80, 30),
		redLambert);

	board.position.x = camera_start.x + 0;
	board.position.y = camera_start.y + 40;
	board.position.z = camera_start.z - 20;

	board.rotation.x = -1.1 + Math.PI/2;

	var unitWidth = 1/12;
	var unitHeight = 1/9;

	var keyboardApp = kM.getKeyboardApp();

	if (kM.hidden) {
		//To unhide, drag up at least a threshold and show bar rising from bottom. Jump on let go.
		kM.topBar.draw(scene, board);
	} else {
		if (kM.topBar.moving) {
			kM.topBar.draw(scene, board);
		} else {
			var objects = [];
			switch(kM.state) {
				case kM.State.Normal:
					if (keyboardApp != null) {
						objects = keyboardApp.keyboard.objects;
					}
					break;
				case kM.State.Notifications:
					if (oldState != kM.state) {
						setUpNotifications();
					}
					objects = kM.notificationKeyboard.objects;
					break;
				case kM.State.AppSwitch:
					if (oldState != kM.state) {
						setUpAppSwitcher();
					}
					objects = kM.appSwitcherKeyboard.objects;
					break;
			}
			oldState = kM.state;
			objects.map(function(object) {
				object.draw(scene, board);
			});

			scene.add(board);
			var circle_amplitude = 0.01;
			for (var i = 0; i < kM.points.length; i++) {
				if (kM.points[i] != null && kM.points[i].x != undefined && kM.points[i].y != undefined ) {
					var circle = makeCircle(circle_amplitude);
					setKeyboardPosition(board, circle, kM.points[i].x, kM.points[i].y, 0.15);
					scene.add(circle);
				}
			}
		}
	}
};


apps.map(function(appURL) {
	//var url = 'http://whateverorigin.org/get?url=' + encodeURIComponent(appURL) + '&callback=?';
/*	$.getJSON(url, function(data){
		eval(data.contents); //Find way to sanitize this.
		kM.add(exports);
	});*/

	$.getScript(appURL, function() {
		//eval(data.contents);
		kM.add(exports);
	});
});


//=========================


/**
 * Adapted from:
 * @author troffmo5 / http://github.com/troffmo5
 *
 * Google Street View viewer for the Oculus Rift
 */

// Parameters
// ----------------------------------------------
var QUALITY = 3;
var DEFAULT_LOCATION = { lat:44.301945982379095,  lng:9.211585521697998 };
var WEBSOCKET_ADDR = "ws://127.0.0.1:1981";
var USE_TRACKER = false;
var MOUSE_SPEED = 0.005;
var KEYBOARD_SPEED = 0.02;
var GAMEPAD_SPEED = 0.04;
var DEADZONE = 0.2;
var SHOW_SETTINGS = true;
var NAV_DELTA = 45;
var FAR = 1000;
var USE_DEPTH = true;
var WORLD_FACTOR = 1.0;
var OculusRift = {
  // Parameters from the Oculus Rift DK1
  hResolution: 1280,
  vResolution: 800,
  hScreenSize: 0.14976,
  vScreenSize: 0.0936,
  interpupillaryDistance: 0.064,
  lensSeparationDistance: 0.064,
  eyeToScreenDistance: 0.041,
  distortionK : [1.0, 0.22, 0.24, 0.0],
  chromaAbParameter: [ 0.996, -0.004, 1.014, 0.0]
};


//var WIDTH, HEIGHT;
var currHeading = 0;
var centerHeading = 0;
var navList = [];

var headingVector = new THREE.Vector3();
var moveVector = new THREE.Vector3();
var keyboardMoveVector = new THREE.Vector3();
var HMDRotation = new THREE.Quaternion();
var BaseRotation = new THREE.Quaternion();
var BaseRotationEuler = new THREE.Vector3();

var VRState = null;

// Utility function
// ----------------------------------------------
function angleRangeDeg(angle) {
  angle %= 360;
  if (angle < 0) angle += 360;
  return angle;
}

function angleRangeRad(angle) {
  angle %= 2*Math.PI;
  if (angle < 0) angle += 2*Math.PI;
  return angle;
}

function deltaAngleDeg(a,b) {
  return Math.min(360-(Math.abs(a-b)%360),Math.abs(a-b)%360);
}


var initWebGL = function() {

	camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
	camera.rotation.x = camera_start.x;
	camera.position.y = camera_start.y;
	camera.position.z = camera_start.z;
	camera.useQuaternion = true;

	// Create render
	try {
		renderer = new THREE.WebGLRenderer( {antialias:true} );
	}
	catch(e){
		alert('This application needs WebGL enabled!');
		return false;
	}

	renderer.autoClearColor = true;
	renderer.setSize(WIDTH, HEIGHT);

	// Set the window resolution of the rift in case of not native
	OculusRift.hResolution = WIDTH, OculusRift.vResolution = HEIGHT,

	effect = new THREE.OculusRiftEffect( renderer, {HMD:OculusRift, worldFactor:WORLD_FACTOR} );
	effect.setSize(WIDTH, HEIGHT );

	var $viewer = $('#viewer');
	$viewer.append(renderer.domElement);
}


function initControls() {
  // Mouse
  // ---------------------------------------
  var viewer = $('#viewer'),
      mouseButtonDown = false,
      lastClientX = 0,
      lastClientY = 0;

  viewer.mousedown(function(event) {
    mouseButtonDown = true;
    lastClientX = event.clientX;
    lastClientY = event.clientY;
  });

  viewer.mouseup(function() {
    mouseButtonDown = false;
  });

  viewer.mousemove(function(event) {
    if (mouseButtonDown) {
      var enableX = (USE_TRACKER || VRState !== null) ? 0 : 1;
      BaseRotationEuler.set(
        angleRangeRad(BaseRotationEuler.x + (event.clientY - lastClientY) * MOUSE_SPEED * enableX),
        angleRangeRad(BaseRotationEuler.y + (event.clientX - lastClientX) * MOUSE_SPEED),
        0.0
      );
      lastClientX = event.clientX;
      lastClientY = event.clientY;
      BaseRotation.setFromEuler(BaseRotationEuler, 'YZX');
    }
  });
}



function initGui()
{
  $('#extt-left').prop('checked', USE_TRACKER);
  $('#extt-right').prop('checked', USE_TRACKER);


  $('#extt-left').change(function(event) {
    USE_TRACKER = $('#extt-left').is(':checked');
    if (USE_TRACKER) {
      WEBSOCKET_ADDR = $('#wsock-left').val();
      initWebSocket();
      BaseRotationEuler.x = 0.0;
      VRState = null;
    }
    else {
      if (connection) connection.close();
      initVR();
    }
    $('#extt-right').prop('checked', USE_TRACKER);
  });

  $('#extt-right').change(function(event) {
    USE_TRACKER = $('#extt-right').is(':checked');
    if (USE_TRACKER) {
      WEBSOCKET_ADDR = $('#wsock-right').val();
      initWebSocket();
      BaseRotationEuler.x = 0.0;
      VRState = null;
    }
    else {
      if (connection) connection.close();
      initVR();
    }
    $('#extt-left').prop('checked', USE_TRACKER);
  });

  $('#wsock-left').change(function(event) {
    WEBSOCKET_ADDR = $('#wsock-left').val();
    if (USE_TRACKER) {
      if (connection) connection.close();
      initWebSocket();
    }
  });

  $('#wsock-right').change(function(event) {
    WEBSOCKET_ADDR = $('#wsock-right').val();
    if (USE_TRACKER) {
      if (connection) connection.close();
      initWebSocket();
    }
  });

  $('#wsock-left').keyup(function() {
      $('#wsock-right').prop('value', $('#wsock-left').val() );
  });

  $('#wsock-right').keyup(function() {
      $('#wsock-left').prop('value', $('#wsock-right').val() );
  });

  $('#depth-left').change(function(event) {
    USE_DEPTH = $('#depth-left').is(':checked');
    $('#depth-right').prop('checked', USE_DEPTH);
    setSphereGeometry();
  });

  $('#depth-right').change(function(event) {
    USE_DEPTH = $('#depth-right').is(':checked');
    $('#depth-left').prop('checked', USE_DEPTH);
    setSphereGeometry();
  });

  window.addEventListener( 'resize', resize, false );

}

function setSphereGeometry() {
  var geom = projSphere.geometry;
  var depthMap = panoDepthLoader.depthMap.depthMap;
  var y, x, u, v, radius, i=0;
  for ( y = 0; y <= geom.heightSegments; y ++ ) {
    for ( x = 0; x <= geom.widthSegments; x ++ ) {
      u = x / geom.widthSegments;
      v = y / geom.heightSegments;

      radius = (USE_DEPTH ? Math.min(depthMap[y*512 + x], FAR) : 500)*10;

      var vertex = geom.vertices[i];
      vertex.x = - radius * Math.cos( geom.phiStart + u * geom.phiLength ) * Math.sin( geom.thetaStart + v * geom.thetaLength );
      vertex.z = radius * Math.cos( geom.thetaStart + v * geom.thetaLength );
      vertex.y = -radius * Math.sin( geom.phiStart + u * geom.phiLength ) * Math.sin( geom.thetaStart + v * geom.thetaLength );
      i++;
    }
  }
  geom.verticesNeedUpdate = true;
}

function initGoogleMap() {
  currentLocation = new google.maps.LatLng( DEFAULT_LOCATION.lat, DEFAULT_LOCATION.lng );
}


function initVR() {
  vr.load(function(error) {
    if (error) {
      //console.warn('VR error: ' + error.toString());
      return;
    }

    VRState = new vr.State();
    if (!vr.pollState(VRState)) {
      //console.warn('NPVR plugin not found/error polling');
      VRState = null;
      return;
    }

    if (!VRState.hmd.present) {
      //console.warn('oculus rift not detected');
      VRState = null;
      return;
    }
    BaseRotationEuler.x = 0.0;
  });
}

function setUiSize() {
  var width = window.innerWidth, hwidth = width/2,
      height = window.innerHeight;
}

function resize( event ) {
  WIDTH = window.innerWidth;
  HEIGHT = window.innerHeight;
  setUiSize();

  OculusRift.hResolution = WIDTH,
  OculusRift.vResolution = HEIGHT,
  effect.setHMD(OculusRift);

  renderer.setSize( WIDTH, HEIGHT );
  camera.projectionMatrix.makePerspective( VIEW_ANGLE, ASPECT, NEAR, FAR );
}

function getParams() {
  var params = {};
  var items = window.location.search.substring(1).split("&");
  for (var i=0;i<items.length;i++) {
    var kvpair = items[i].split("=");
    params[kvpair[0]] = unescape(kvpair[1]);
  }
  return params;
}

var pointLight = new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 50;
pointLight.position.y = 50;
pointLight.position.z = 300;

var directLight = new THREE.DirectionalLight(0xFFFFFF);

directLight.position.x = 0;
directLight.position.y = 0;
directLight.position.z = 1;

var projGeo = new THREE.SphereGeometry( 5000, 512, 256 );
var projMaterial = new THREE.MeshBasicMaterial({ map: THREE.ImageUtils.loadTexture('placeholder.png'), side: THREE.DoubleSide});

var render = function() {

	requestAnimationFrame( render );

	if (!USE_TRACKER && VRState !== null) {
		if (vr.pollState(VRState)) {
			HMDRotation.set(VRState.hmd.rotation[0], VRState.hmd.rotation[1], VRState.hmd.rotation[2], VRState.hmd.rotation[3]);
		}
	}

	// Compute move vector
	moveVector.add(keyboardMoveVector);//, gamepadMoveVector);

	// Disable X movement HMD tracking is enabled
	if (USE_TRACKER || VRState !== null) {
		moveVector.x = 0;
	}

	// Apply movement
	BaseRotationEuler.set( angleRangeRad(BaseRotationEuler.x + moveVector.x), angleRangeRad(BaseRotationEuler.y + moveVector.y), 0.0 );
	BaseRotation.setFromEuler(BaseRotationEuler, 'YZX');

	var matr = new THREE.Matrix4();
	matr.makeRotationFromQuaternion(BaseRotation);

	var tilt = new THREE.Matrix4();
	tilt.makeRotationX(Math.PI/2);
	matr.multiplyMatrices(tilt, matr);
	BaseRotation.setFromRotationMatrix(matr);

	// Update camera rotation
	camera.quaternion.multiplyQuaternions(BaseRotation, HMDRotation);

	// Compute heading
	headingVector.setEulerFromQuaternion(camera.quaternion, 'YZX');
	currHeading = angleRangeDeg(THREE.Math.radToDeg(-headingVector.y));

	scene = new THREE.Scene();

	if(kM.front_and_back != null) {
		kM.front_and_back.external.drawFrontAndBack(scene);
	} else {
		if (kM.front != null) {
			kM.front.external.drawFront(scene);
		}
		if (kM.back != null) {
			kM.back.external.drawBack(scene);
		}
	}
	kM.drawKeyboard(scene);

	scene.add(camera);
	scene.add(directLight);

	//renderer.clear();
	effect.render(scene, camera);
};

$(document).ready(function() {

  // Read parameters
  params = getParams();
  if (params.lat !== undefined) DEFAULT_LOCATION.lat = params.lat;
  if (params.lng !== undefined) DEFAULT_LOCATION.lng = params.lng;
  if (params.sock !== undefined) {WEBSOCKET_ADDR = 'ws://'+params.sock; USE_TRACKER = true;}
  if (params.q !== undefined) QUALITY = params.q;
  if (params.s !== undefined) SHOW_SETTINGS = params.s !== "false";
  if (params.heading !== undefined) {
    BaseRotationEuler.set(0.0, angleRangeRad(THREE.Math.degToRad(-parseFloat(params.heading))) , 0.0 );
    BaseRotation.setFromEuler(BaseRotationEuler, 'YZX');
  }
  if (params.depth !== undefined) USE_DEPTH = params.depth !== "false";
  if (params.wf !== undefined) WORLD_FACTOR = parseFloat(params.wf);


  WIDTH = window.innerWidth; HEIGHT = window.innerHeight;

  setUiSize();

  initWebGL();
  initControls();
  initGui();
  if (USE_TRACKER) initWebSocket();
  else initVR();

  render();
});

</script>
</body>
</html>