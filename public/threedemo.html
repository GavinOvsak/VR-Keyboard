<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>Three JS Demo</title>
</head>
<body>
<script src="http://162.222.183.103/socket.io/socket.io.js"></script>
<script src="http://162.222.183.103/three.min.js"></script>
<script src="http://162.222.183.103/jquery-1.10.1.min.js"></script>
<div id="code"></div>
<div id="container"></div>
<script>
//Required for apps
var  VRK = {};
//keyboard is an 8 x 12 grid
var Button = function(x, y, width, height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
Button.prototype.onClick = function(callback) {
	this.onClick_callback = callback;
}

VRK.Button = Button;

</script>

<script>


//Make registry of javascript apps.

var apps = [
	'/galaxy.js',
	'/chess.js'
];

//Keyboard
//make buttons work.
//make joysticks

var WIDTH = 1200,
  HEIGHT = 800;

var VIEW_ANGLE = 45,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 10000;

var $container = $('#container');

var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
var renderer = new THREE.WebGLRenderer();

camera.position.z = 300;

$container.mousemove(function(event) {
	camera.position.x = -1 * (event.pageX - 300) / 30;
	camera.position.y = (event.pageY - 200) / 30;
});

renderer.setSize(WIDTH, HEIGHT);
$container.append(renderer.domElement);

var redLambert = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
var blueLambert = new THREE.MeshLambertMaterial({ color: 0x0000CC });
var greenLambert = new THREE.MeshLambertMaterial({ color: 0x00CC00 });

var pointLight = new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 50;
pointLight.position.y = 50;
pointLight.position.z = 300;

var directLight = new THREE.DirectionalLight(0xFFFFFF);

directLight.position.x = 0;
directLight.position.y = 0;
directLight.position.z = 1;

//var ambientLight =
//  new THREE.AmbientLight(0xCC0000);

var scene = new THREE.Scene();

var kM = {
	apps: [],
	front: null,
	back: null,
	front_and_back: null,
	points: []
};

var socket = io.connect('http://162.222.183.103/');
socket.emit('declare-type', 'output');

var device_width = WIDTH;
var device_height = HEIGHT;

socket.on('size', function (data) {
	device_width = JSON.parse(data).width;
	device_height = JSON.parse(data).height;
	console.log(data);
});

var key_pointers = [];

var rectContains = function(point, x, y, width, height) {
	return point.x > x && point.x < x + width && point.y > y && point.y < y + height;
};

var vector = function(a, b) {
	return {x: b.x-a.x, y: b.y-a.y};
}

var dot = function(a, b) {
	return a.x*b.x+a.y*b.y;
}

var length = function(a) {
	return Math.sqrt(a.x*a.x+a.y*a.y);
}

var distance = function(a, b) {
	return length(vector(a,b));
}

var angle = function(a, b) {
	return Math.acos(dot(a,b)/(length(a)*length(b)));
}

var scale = function(a, x_scale, y_scale) {
	return {
		x: a.x*x_scale,
		y: a.y*y_scale
	}
}

/*var dragDist = function(pointer) {
	return distance(scale(pointer, x_scale, y_scale), scale(pointer.start, x_scale, y_scale));
}*/

socket.on('code', function (code) {
	console.log(code);
	screen_code = document.getElementById( 'code' );
	screen_code.innerText = 'Use this code to connect: ' + code;
});

socket.on('start', function (data) {
	parsed = JSON.parse(data);
	kM.start(parsed);
//	console.log('start');
//	console.log(parsed);

	//If inside a button, and the button isn't already claimed, claim button.
	//two slider grips are also buttons.
/*	for (var i = 0; i < keys.length; i++) {
		if (!key_pointers[i] && rectContains(parsed, keys[i].x*keyboard_scale_x, keys[i].y*keyboard_scale_y, keys[i].width*keyboard_scale_x, keys[i].height*keyboard_scale_y)) {
			key_pointers[i] = parsed.i;
		}
	}*/

//	repaint();
});

socket.on('move', function (data) {
	parsed = JSON.parse(data);
	kM.move(parsed);
//	console.log('move');
//	console.log(parsed);

//	repaint();
});

socket.on('end', function (data) {
	parsed = JSON.parse(data);
	kM.end(parsed);
//	console.log('end');
//	console.log(parsed);
//	kM.points[parsed.i] = {};

	//Todo: if was in button, and is outside threshold, trigger button.

/*	for(var i = 0; i < key_pointers.length; i++) {
		if (key_pointers[i] != undefined && key_pointers[i] == parsed.i) {
			key_pointers[i] = undefined;
		}
	}*/

//	repaint();
});

kM.open = function(app) {
	if (app.external.drawFront != null) {
		//if front and back app has back, push to back
		if (kM.front_and_back != null && kM.front_and_back.external.drawBack != null) {
			kM.back = kM.front_and_back;
		}
		kM.front_and_back = null;
		kM.front = app;
	} else if(app.external.drawFrontAndBack) {
		kM.front = null;
		kM.back = null;
		kM.front_and_back = app;
	} else if(app.external.drawBack) {
		kM.front_and_back = null;
		kM.back = app;
	}
};

kM.add = function(extern) {
	var app = {
		external: extern,
		keyboard: {
			buttons: [],
			add: function(button){
				app.keyboard.buttons.push(button);
			}
		}
	};
	kM.apps.push(app);
	app.external.setUpKeyboard(app.keyboard);
	kM.open(app);
};

kM.minimize = function() {
	if (kM.front_and_back != null && kM.front_and_back.external.drawFront != null) {
		kM.front = kM.front_and_back;
		kM.front_and_back = null;
	}
};
kM.maximize = function() {
	if (kM.front != null && kM.front.external.drawFrontAndBack != null) {
		kM.front_and_back = kM.front;
		kM.front = null;
		kM.back = null;
	}
};

kM.close = function() {
	if (kM.front != null) {
		if (kM.back != null && kM.back.external.drawFrontAndBack != null) {
			kM.front_and_back = kM.back;
			kM.back = null;
		}
		kM.front = null;
	} else if (kM.front_and_back != null) {
		kM.front_and_back = null;
	} else if (kM.back != null) {
		kM.back = null;
	}
}

kM.start = function(update) {
	kM.points[update.i] = {
		start: {
			x: update.x/device_width,
			y: 1 - update.y/device_height},
		x: update.x/device_width,
		y: 1 - update.y/device_height
	};
};

kM.move = function(update) {
	kM.points[update.i].x = update.x/device_width;
	kM.points[update.i].y = 1 - update.y/device_height;

	//check kM.screenApp.buttons
};
kM.end = function(update) {
	kM.points[update.i] = {};

	//check kM.screenApp.buttons
	//if so, activate them.
};


/*

Apps can have any set of the three functions f, b, f_b

New apps open at f, if no f, go to fb, if no fb, go to b. Doesn't depend on existing apps.
If existing app conflicts, close, unless was at fb, then go to b if doesn't conflict.

Only can control with keyboard in f and f_b. Maximize and minimize goes between them. App can control this. If you maximize and then minimize, it closes any background app.

Only way to get background app if to be in f_b and open a new f.

=> If you have a b, you must have an fb.


Keyboard top bar:
left = close. Center bar has name and can drag down. Right button max/min. Right button 2 app is app switcher.

*/


kM.drawKeyboard = function(scene) {
	var board = new THREE.Mesh(
		new THREE.PlaneGeometry(80, 30),
		redLambert);

	board.position.x = 0;
	board.position.y = -20;
	board.position.z = 210;
	board.rotation.x = -1.1;

	scene.add(board);

	var buttonWidth = board.geometry.width/12;
	var buttonHeight = board.geometry.height/9;

	var buttonMesh;

	var buttons;
	if (kM.front_and_back != null) {
		buttons = kM.front_and_back.keyboard.buttons;
	} else if (kM.front != null) {
		buttons = kM.front.keyboard.buttons;
	}

	topBar = new THREE.Mesh(
		new THREE.PlaneGeometry(board.geometry.width, buttonHeight),
		greenLambert);

	//var x_displacement = buttonWidth * (buttons[i].x + buttons[i].width/2) - board.geometry.width/2;
	var y_displacement = buttonHeight * (8 + 1/2) - board.geometry.height/2;
	var z_displacement = 0.1;

	topBar.position.x = 0;
	topBar.position.y = board.position.y + y_displacement * Math.cos(board.rotation.x) - z_displacement * Math.sin(board.rotation.x);
	topBar.position.z = board.position.z + y_displacement * Math.sin(board.rotation.x) + z_displacement * Math.cos(board.rotation.x);

	topBar.rotation.x = board.rotation.x;
	scene.add(topBar);

	if (kM.front_and_back != null || kM.front != null) {
		for(var i = 0; i < buttons.length; i++) {
			buttonMesh = new THREE.Mesh(
				new THREE.PlaneGeometry(buttonWidth*buttons[i].width, buttonHeight*buttons[i].height),
				greenLambert);

			var x_displacement = buttonWidth * (buttons[i].x + buttons[i].width/2) - board.geometry.width/2;
			var y_displacement = buttonHeight * (buttons[i].y + buttons[i].height/2) - board.geometry.height/2;
			var z_displacement = 0.1;

			buttonMesh.position.x = board.position.x + x_displacement;
			buttonMesh.position.y = board.position.y + y_displacement * Math.cos(board.rotation.x) - z_displacement * Math.sin(board.rotation.x);
			buttonMesh.position.z = board.position.z + y_displacement * Math.sin(board.rotation.x) + z_displacement * Math.cos(board.rotation.x);

			buttonMesh.rotation.x = board.rotation.x;
			scene.add(buttonMesh);
		}
	}

	var circle_geometry;
	var greenLine = new THREE.LineBasicMaterial({color: 0x999999});

	var circle_resolution = 40;
	var circle_amplitude = 1;

	for (var i = 0; i < kM.points.length; i++) {
		if (kM.points[i] != null && kM.points[i].x != undefined && kM.points[i].y != undefined ) {
			circle_geometry = new THREE.Geometry();
			for(var j = 0; j <= circle_resolution; j++) {
				var theta = (j / circle_resolution) * Math.PI * 2;

				var x_displacement = kM.points[i].x * board.geometry.width + circle_amplitude * Math.cos(theta) - board.geometry.width / 2;
				var y_displacement = kM.points[i].y * board.geometry.height + circle_amplitude * Math.sin(theta) - board.geometry.height / 2;
				var z_displacement = 0.15;

				circle_geometry.vertices.push( new THREE.Vector3(
						board.position.x + x_displacement, 
						board.position.y + y_displacement * Math.cos(board.rotation.x) - z_displacement * Math.sin(board.rotation.x),
						board.position.z + y_displacement * Math.sin(board.rotation.x) + z_displacement * Math.cos(board.rotation.x)
				));
				scene.add(new THREE.Line(circle_geometry, greenLine));
			}
		}
	}
};

$.getScript(apps[0], function() {
	console.log('app 0 loaded');
	kM.add(exports);
});
$.getScript(apps[1], function() {
	console.log('app 1 loaded');
	kM.add(exports);
});

/*
kM.open(kM.apps[1]);
kM.open(kM.apps[0]);*/
//kM.maximize();
//kM.minimize();

var render = function() {
	window.requestAnimationFrame(render);

	scene = new THREE.Scene();

	if(kM.front_and_back != null) {
		kM.front_and_back.external.drawFrontAndBack(scene);
	} else {
		if (kM.front != null) {
			kM.front.external.drawFront(scene);
		}
		if (kM.back != null) {
			kM.back.external.drawBack(scene);
		}
	}
	kM.drawKeyboard(scene);

	scene.add(camera);
	scene.add(directLight);
	renderer.render(scene, camera);
};
render();

</script>
</body>
</html>