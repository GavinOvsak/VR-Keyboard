<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>Three JS Demo</title>
</head>
<body>
<script src="http://162.222.183.103/socket.io/socket.io.js"></script>
<script src="http://162.222.183.103/three.min.js"></script>
<script src="http://162.222.183.103/jquery-1.10.1.min.js"></script>
<script src="http://162.222.183.103/utility.js"></script>
<div id="code"></div>
<div id="container"></div>
<script>

//Required for apps
var VRK = {};

//focus on top bar
//make close button
//maximize and minimize buttons
//app switcher button

var makeText = function(text, px, width, height) {
	var canvas1 = document.createElement('canvas');
	canvas1.height = px;
	canvas1.width = 100;
    var context1 = canvas1.getContext('2d');
    context1.font = "Bold "+px+"px Arial";
    context1.fillStyle = "rgba(255,0,0,0.95)";
    context1.fillText(text, 0, 30);
    var texture1 = new THREE.Texture(canvas1) 
    texture1.needsUpdate = true;
    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
    material1.transparent = true;
    var closeMesh = new THREE.Mesh(new THREE.PlaneGeometry(width, height), material1);
};

VRK.Button = function(x, y, width, height, text) {
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.text = text || '';
	this.px = 30;
	this.width = width * unitWidth;
	this.height = height * unitHeight;
	this.available = true;
	this.threshold_distance = 0.1;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.point = undefined;
	this.contains = function(x, y) {
		return x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height;
	};
	this.onClick_callback = function(){};
	this.click = function(){
		this.onClick_callback();
	};
	this.onClick = function(callback) {
		this.onClick_callback = callback;
	};
	this.release = function(x, y) {
		this.available = true;
		this.point = undefined;
		//if far enough, click.
		if (this.dragDistance() < this.threshold_distance) {
			this.click();
		}
	};
	this.dragDistance = function() {
		if(this.point != undefined) {
			return Math.sqrt(
				Math.pow(this.point.x - this.initGrab.x, 2) + 
				Math.pow(this.point.y - this.initGrab.y, 2));
		}
		return 0;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		this.available = false;
	};
	this.draw = function(scene, board) {
		//change color based on distance
		var distance = this.dragDistance();
		var percentClicked = Math.min(distance/this.threshold_distance, 1);

		var materialOptions = {};
		if (this.point != null) {
			materialOptions.color = (0 << 16) + (200*(1-percentClicked) << 8) + percentClicked*255;
		} else {
			materialOptions.color = (0 << 16) + (200 << 8) + 0;
		}

		var material = new THREE.MeshLambertMaterial(materialOptions);

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);

		var canvas1 = document.createElement('canvas');
		canvas1.height = this.px;
		canvas1.width = 100;
        var context1 = canvas1.getContext('2d');
        context1.font = "Bold " + this.px + "px Arial";
        context1.fillStyle = "rgba(255,0,0,0.95)";
	    context1.fillText(this.text, 0, this.px);
        var texture1 = new THREE.Texture(canvas1) 
        texture1.needsUpdate = true;
	    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
	    material1.transparent = true;
	    var textmesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material1);
	    
	    setKeyboardPosition(board, textmesh, this.x, this.y, 0.2);
        scene.add( textmesh );
	}
};

VRK.LinearSlider = function(x, y, width, length, returnsToCenter, direction) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.length = length;
	this.returnsToCenter = returnsToCenter;
	this.direction = direction;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		//draw this.text;
	};
};

VRK.ArcSlider = function(x, y, returnsToCenter, radius, beginAngle, endAngle) {
	this.x = x;
	this.y = y;
	this.returnsToCenter = returnsToCenter;
	this.radius = radius;
	this.beginAngle = beginAngle;
	this.endAngle = endAngle;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		//draw this.text;
	};
};
VRK.Label = function(x, y, width, height, text, px){
	this.x = x;
	this.y = y;
	this.width = width/12;
	this.height = height/9;
	this.text = text;
	this.px = px || 30;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		
		var canvas1 = document.createElement('canvas');
		canvas1.height = this.px;
		canvas1.width = 100;
        var context1 = canvas1.getContext('2d');
        context1.font = "Bold " + this.px + "px Arial";
        context1.fillStyle = "rgba(255,0,0,0.95)";
	    context1.fillText(this.text, 0, this.px);
        var texture1 = new THREE.Texture(canvas1) 
        texture1.needsUpdate = true;
	    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
	    material1.transparent = true;
	    var textmesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material1);
	    
	    setKeyboardPosition(board, textmesh, this.x, this.y, 0.2);
        scene.add( textmesh );		
	};
};

VRK.Treadmill = function(x, y, width, height, canZoom, canRotate){
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		//draw this.text;
	};
};

VRK.KeyboardObject = function(x, y, width, height){
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
	};
};

//moves whole keyboard down when dragged. When buttons are pressed, changes state
VRK.SystemBar = function(x, y, width, height){
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
	this.buttonPosition = {
		'inClose': 0 * unitWidth,
		'inNotifications': 1 * unitWidth,
		'inAppSwitch': 10 * unitWidth,
		'inMaxMin': 11 * unitWidth
	};
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.available = true;
	this.point = undefined;
	this.buttonSelected = undefined;
	this.contains = function(x, y) {
		return this.whichButton(x, y) != 'none';
	};
	this.moving = false;
	this.whichButton = function(x,y) {
		if (kM.state == 'hidden') {
			return 'hideBar';
		} else {
			if (y > this.y) {
				if (x > 2 * unitWidth && x < 10 * unitWidth) {
					return 'hideBar';
				}
				for (state in this.buttonPosition) {
					if (x < this.buttonPosition[state] && x > this.buttonPosition[state] + unitWidth) {
						return state;
					}
				}
			}
			return 'none';
		}
	}
	this.release = function(x, y) {
		this.available = true;
		this.point = undefined;

		//if far enough, click.
		if (this.buttonPosition.contains(this.buttonSelected) && this.dragDistance() < this.threshold_distance) {
			this.click(this.buttonSelected);
		} else if (this.buttonSelected == 'hidden') {
			if (y > 0.5) {
				kM.state = kM.State.Normal;
			} else {
				kM.state = kM.State.Hidden;
			}
		}
	};
	this.click = function(buttonName){
		switch(buttonName) {
			case 'inClose':
				kM.close();
				//Either expand other app, or go to app switcher. Try not to have no apps.
				//kM.state = kM.State.Empty;
				break;
			case 'inNotifications':
				kM.state = kM.State.Notifications;
				break;
			case 'inAppSwitch':
				kM.state = kM.State.AppSwitch;
				break;
			case 'inMaxMin':
				break;
		}
	};
	this.dragDistance = function() {
		if(this.point != undefined) {
			return distance(this.point, this.initGrab);
			/*Math.sqrt(
				Math.pow(this.point.x - this.initGrab.x, 2) + 
				Math.pow(this.point.y - this.initGrab.y, 2));*/
		}
		return 0;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.buttonSelected = this.whichButton(point.x, point.y);
		this.point = point;
		point.onRelease(this.release.bind(this));
		point.onMove(this.move.bind(this));
		this.available = false;
	};
	this.draw = function(scene, board) {
		var distance = this.dragDistance();
		var percentClicked = Math.min(distance/this.threshold_distance, 1);

		if (kM.state != 'hidden' || this.buttonSelected == 'hideBar') {
			var barMaterial = new THREE.MeshLambertMaterial({color: 0x00CC00});

			var barMesh = new THREE.Mesh(
				new THREE.PlaneGeometry(this.width, this.height), barMaterial);
			
			setKeyboardPosition(board, barMesh, this.x, this.y, 0.1);

			this.moving = false;
			var adjusted_y = this.y
			if (this.point != undefined) {
				adjusted_y = this.y + (this.point.y - this.initGrab.y);
			}
			if (this.buttonSelected == 'hideBar') {
				setKeyboardPosition(board, barMesh, this.x, adjusted_y, 0.1);
				this.moving = true;
			} else if (this.buttonSelected != 'none') {
				//change color based on distance
				var materialOptions = {color: 0x00CC00};
				if (this.point != null) {
					materialOptions.color = (0 << 16) + (200*(1-percentClicked) << 8) + percentClicked*255;
				}

				var buttonMaterial = new THREE.MeshLambertMaterial(materialOptions);
				var buttonMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(unitWidth, unitHeight), buttonMaterial);

				setKeyboardPosition(board, buttonMesh, this.x + this.buttonPosition[this.buttonSelected], adjusted_y, 0.12);

				scene.add(buttonMesh);
			}
			scene.add(barMesh);

			var closeMesh = makeText('X', 30, unitWidth, unitHeight);
			setKeyboardPosition(board, closeMesh, this.x + this.buttonPosition['inClose'], adjusted_y, 0.13);
			scene.add(closeMesh);
	
			var notifyMesh = makeText(' !', 30, unitWidth, unitHeight);
			setKeyboardPosition(board, notifyMesh, this.x + this.buttonPosition['inNotifications'], adjusted_y, 0.13);
			scene.add(notifyMesh);
	
			var appSwitchMesh = makeText('<->', 30, unitWidth, unitHeight);
			setKeyboardPosition(board, appSwitchMesh, this.x + this.buttonPosition['inAppSwitch'], adjusted_y, 0.13);
			scene.add(appSwitchMesh);
	
			var maxMinMesh = makeText('+/-', 30, unitWidth, unitHeight);
			setKeyboardPosition(board, maxMinMesh, this.x + this.buttonPosition['inMaxMin'], adjusted_y, 0.13);
			scene.add(maxMinMesh);
		}
	}
};

VRK.Joystick = function(x, y, returnsToCenter) {
	var unitWidth = 1/12;
	var unitHeight = 1/9;
	
	this.x = x * unitWidth;
	this.y = y * unitHeight;

	this.returnsToCenter = returnsToCenter;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.radius = 0.04;
	this.available = true;
	this.point = undefined;
	this.contains = function(x, y) {
		return Math.sqrt(Math.pow(x - this.x,2) + Math.pow((y - this.y) / eccentricity,2)) < this.radius;
	};
	this.release = function(x, y) {
		this.available = true;
		this.onRelease_callback(x - this.x, y - this.y);
		this.point = undefined;
	};
	this.onRelease_callback = function(x, y) {};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y) {};
	this.move = function(x, y){
		this.onMove_callback(x - this.x, y - this.y);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		point.onMove(this.move.bind(this));
		this.available = false;
	};

	this.draw = function(scene, board) {
		var grab = makeFullCircle(this.radius);
		
		var shifted_x = this.x;
		var shifted_y = this.y;
		if(this.point != undefined) {
			shifted_x = this.point.x - this.initGrab.x + this.x;
			shifted_y = this.point.y - this.initGrab.y + this.y;
		}
		setKeyboardPosition(board, grab, shifted_x, shifted_y, 0.12);

		scene.add(grab);
	};
};

var Point = function(x, y) {
	this.start = {
		x: x,
		y: y
	}
	this.x = x;
	this.y = y;
	this.taken = false;
	this.onRelease_callback = function() {};
	this.release = function() {
		this.onRelease_callback();
	};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y) {};
	this.move = function(x, y) {
		this.x = x;
		this.y = y;
		this.onMove_callback(x, y);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	}
};

var kM = {
	apps: [],
	front: null,
	back: null,
	front_and_back: null,
	keyboardApp: null,
	points: []
};

kM.topBar = new VRK.SystemBar(0, 1/9 * (8 + 1/2), 1, 1/9);

//keyboard is an 8 x 12 grid
VRK.Keyboard = function(app) {
	this.objects = [kM.topBar];
	this.add = function(button){
		this.objects.push(button);
	};
};

var apps = [
	'/galaxy.js',
	'/chess.js'
];

var WIDTH = 1200,
  HEIGHT = 800;

var VIEW_ANGLE = 45,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 10000;

var $container = $('#container');

var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
var renderer = new THREE.WebGLRenderer();

camera.position.z = 300;

$container.mousemove(function(event) {
	camera.position.x = -1 * (event.pageX - 300) / 30;
	camera.position.y = (event.pageY - 200) / 30;
});

renderer.setSize(WIDTH, HEIGHT);
$container.append(renderer.domElement);

var pointLight = new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 50;
pointLight.position.y = 50;
pointLight.position.z = 300;

var directLight = new THREE.DirectionalLight(0xFFFFFF);

directLight.position.x = 0;
directLight.position.y = 0;
directLight.position.z = 1;

//var ambientLight =
//  new THREE.AmbientLight(0xCC0000);

var checkGrab = function(point) {
	if (kM.keyboardApp != null && !kM.topBar.moving) {
		var objects = kM.keyboardApp.keyboard.objects;
		objects.map(function(object) {
			if (object.available && object.contains(point.x, point.y)) {
				object.registerPoint(point);
				point.taken = true;
			}
		});
	}
	if (kM.state = kM.State.Hidden && kM.topBar.available && !point.taken) {
		kM.topBar.registerPoint(point);
		point.taken = true;
	}
}

var scene = new THREE.Scene();

kM.State = {
	Normal: 'normal',
	Hidden: 'hidden',
	AppSwitch: 'app-switch',
	Notifications: 'notifications',
	Empty: 'empty'
};
kM.state = kM.State.Normal;

var socket = io.connect('http://162.222.183.103/');
socket.emit('declare-type', 'output');

var device_width = WIDTH;
var device_height = HEIGHT;

socket.on('size', function (data) {
	device_width = JSON.parse(data).width;
	device_height = JSON.parse(data).height;
});

socket.on('code', function (code) {
	screen_code = document.getElementById( 'code' );
	screen_code.innerText = 'Use this code to connect: ' + code;
});

socket.on('start', function (data) {
	var parsed = JSON.parse(data);
	var point = new Point(parsed.x/device_width, 1 - parsed.y/device_height);
	kM.points[parsed.i] = point;
	checkGrab(point);
});

socket.on('move', function (data) {
	var parsed = JSON.parse(data);
	var point = kM.points[parsed.i];
	point.move(parsed.x/device_width, 1 - parsed.y/device_height);
	if (!point.taken) {
		checkGrab(point);
	}
});

socket.on('end', function (data) {
	var parsed = JSON.parse(data);
	kM.points[parsed.i].release(parsed.x/device_width, 1 - parsed.y/device_height);
	kM.points[parsed.i] = {};
});

kM.open = function(app) {
	if (app.external.drawFront != null) {
		//if front and back app has back, push to back
		if (kM.front_and_back != null && kM.front_and_back.external.drawBack != null) {
			kM.back = kM.front_and_back;
		}
		kM.front_and_back = null;
		kM.front = app;
		kM.keyboardApp = app;
	} else if(app.external.drawFrontAndBack) {
		kM.front = null;
		kM.back = null;
		kM.front_and_back = app;
		kM.keyboardApp = app;
	} else if(app.external.drawBack) {
		kM.front_and_back = null;
		kM.back = app;
	}
};

kM.add = function(extern) {
	var app = {};
	app.external = extern;
	app.keyboard = new VRK.Keyboard(app);
	app.name = extern.name;
	app.icon = extern.icon;
	kM.apps.push(app);
	app.external.setUpKeyboard(app.keyboard);
	kM.open(app);
};

kM.minimize = function() {
	if (kM.front_and_back != null && kM.front_and_back.external.drawFront != null) {
		kM.front = kM.front_and_back;
		kM.front_and_back = null;
		kM.keyboardApp = kM.front_and_back;
	}
};
kM.maximize = function() {
	if (kM.front != null && kM.front.external.drawFrontAndBack != null) {
		kM.front_and_back = kM.front;
		kM.front = null;
		kM.back = null;
	}
};

kM.close = function() {
	if (kM.front != null) {
		if (kM.back != null && kM.back.external.drawFrontAndBack != null) {
			kM.front_and_back = kM.back;
			kM.back = null;
		}
		kM.front = null;
		kM.keyboardApp = null;
	} else if (kM.front_and_back != null) {
		kM.front_and_back = null;
		kM.keyboardApp = null;
	} else if (kM.back != null) {
		kM.back = null;
	}
}


/*

Apps can have any set of the three functions f, b, f_b

New apps open at f, if no f, go to fb, if no fb, go to b. Doesn't depend on existing apps.
If existing app conflicts, close, unless was at fb, then go to b if doesn't conflict.

Only can control with keyboard in f and f_b. Maximize and minimize goes between them. App can control this. If you maximize and then minimize, it closes any background app.

Only way to get background app if to be in f_b and open a new f.

=> If you have a b, you must have an fb.

Keyboard top bar:
Left = close. Left button 2 is notifications. Center bar has name and can drag down. Right button max/min. Right button 2 app is app switcher.

*/

kM.drawKeyboard = function(scene) {
	var redLambert = new THREE.MeshLambertMaterial({ color: 0xCC0000 });

	var board = new THREE.Mesh(
		new THREE.PlaneGeometry(80, 30),
		redLambert);

	board.position.x = 0;
	board.position.y = -20;
	board.position.z = 210;
	board.rotation.x = -1.1;

	var buttonWidth = 1/12;
	var buttonHeight = 1/9;

	switch(kM.state) {
		case kM.State.Normal:
			scene.add(board);
			//when going down, don't show keyboard objects, just bar.
			//If the bar is let go below the hald way, continue to hide. If let go above half way, don't hide.

			//Draw Top Bar;
			
			/*	new THREE.Mesh(
				new THREE.PlaneGeometry(1, buttonHeight),
				greenLambert);*/
			//topBar.draw(scene, board);
			if (kM.topBar.moving) {
				kM.topBar.show(scene, board);
			} else {
				//Draw Keyboard Objects
				if (kM.keyboardApp != null) {
					var objects = kM.keyboardApp.keyboard.objects;
					if (kM.front_and_back != null || kM.front != null) {
						objects.map(function(object) {
							object.draw(scene, board);
						});
					}
				}

				//Draw fingers
				var circle_amplitude = 0.01;
				for (var i = 0; i < kM.points.length; i++) {
					if (kM.points[i] != null && kM.points[i].x != undefined && kM.points[i].y != undefined ) {
						var circle = makeCircle(circle_amplitude);
						setKeyboardPosition(board, circle, kM.points[i].x, kM.points[i].y, 0.15);
						scene.add(circle);
					}
				}
			}
			break;

		case kM.State.Hidden:
			//To unhide, drag up at least a threshold and show bar rising from bottom. Jump on let go.
			kM.topBar.show(scene, board);
			break;

		case kM.State.Notifications:
			scene.add(board);
			kM.topBar.show(scene, board);
			break;

		case kM.State.AppSwitch:
			scene.add(board);
			kM.topBar.show(scene, board);
			break;
	}
};

$.getJSON('http://whateverorigin.org/get?url=' + encodeURIComponent('http://162.222.183.103'+apps[0]) + '&callback=?', function(data){
	eval(data.contents);
	kM.add(exports);
});

$.getJSON('http://whateverorigin.org/get?url=' + encodeURIComponent('http://162.222.183.103'+apps[1]) + '&callback=?', function(data){
	eval(data.contents);
	kM.add(exports);
});

/*
kM.open(kM.apps[1]);
kM.open(kM.apps[0]);*/
//kM.maximize();
//kM.minimize();

var render = function() {
	window.requestAnimationFrame(render);

	scene = new THREE.Scene();

	if(kM.front_and_back != null) {
		kM.front_and_back.external.drawFrontAndBack(scene);
	} else {
		if (kM.front != null) {
			kM.front.external.drawFront(scene);
		}
		if (kM.back != null) {
			kM.back.external.drawBack(scene);
		}
	}
	kM.drawKeyboard(scene);

	scene.add(camera);
	scene.add(directLight);
	renderer.render(scene, camera);
};
render();

</script>
</body>
</html>