<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>Three JS Demo</title>
</head>
<body>
<script src="http://162.222.183.103/socket.io/socket.io.js"></script>
<script src="http://162.222.183.103/three.min.js"></script>
<script src="http://162.222.183.103/jquery-1.10.1.min.js"></script>
<script src="http://162.222.183.103/utility.js"></script>
<div id="code"></div>
<div id="container"></div>
<script>

//Required for apps
var VRK = {};

//keyboard is an 8 x 12 grid
VRK.Keyboard = function(app) {
	this.objects = [];
	this.add = function(button){
		this.objects.push(button);
	};
};

//Keyboard
//make buttons work.
//make joysticks work.

VRK.Button = function(x, y, width, height, text) {
	var greenLambert = new THREE.MeshLambertMaterial({ color: 0x00CC00 });

	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.text = text;
	this.width = width * unitWidth;
	this.height = height * unitHeight;
	this.available = true;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.point = undefined;
	this.contains = function(board, x, y) {
		return x > this.x && x < this.x + this.width && y > this.y && y < (this.y + this.height) * eccentricity;
	};
	this.onClick_callback = function(){};
	this.click = function(){
		this.onClick_callback();
	};
	this.release = function(x, y) {
		this.available = true;
		this.point = undefined;
		//if far enough, click.
		this.click();
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		this.available = false;
	};
	this.onClick = function(callback) {
		this.onClick_callback = callback;
	};
	this.draw = function(scene, board) {
		//change color based on distance
		var distance = 0;
		if(this.point != undefined) {
			distance = Math.sqrt(
				Math.pow(this.point.x - (this.x + this.width/2), 2) + 
				Math.pow(this.point.y - (this.y + this.height/2), 2));
		}

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			greenLambert);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
	}
};

//slider can be a super class of joystick;

VRK.LinearSlider = function(x, y, width, length, returnsToCenter, direction) {};
VRK.ArcSlider = function(x, y, returnsToCenter, radius, beginAngle, endAngle) {};
VRK.Label = function(x, y, width, height, text){};
VRK.Treadmill = function(x, y, width, height, canZoom, canRotate){};
VRK.KeyboardObject = function(x, y, width, height){};
VRK.SystemBar = function(){};
//moves whole keyboard down when dragged. When buttons are pressed, changes state

VRK.Joystick = function(x, y, returnsToCenter) {
	var greenLambert = new THREE.MeshLambertMaterial({ color: 0x00CC00 });

	var unitWidth = 1/12;
	var unitHeight = 1/9;
	
	this.x = x * unitWidth;
	this.y = y * unitHeight;

	this.returnsToCenter = returnsToCenter;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.radius = 0.04;
	this.available = true;
	this.point = undefined;
	this.contains = function(x, y) {
		return Math.sqrt(Math.pow(x - this.x,2) + Math.pow(y - this.y,2)) < this.radius;
	};
	this.release = function(x, y) {
		this.available = true;
		this.onRelease_callback(x - this.x, y - this.y);
		this.point = undefined;
	};
	this.onRelease_callback = function(x, y) {};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y) {};
	this.move = function(x, y){
		this.onMove_callback(x - this.x, y - this.y);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		point.onMove(this.move.bind(this));
		this.available = false;
	};

	this.draw = function(scene, board) {
		//need to fill in circle.
		var grab = makeFullCircle(this.radius);
		
		var shifted_x = this.x;
		var shifted_y = this.y;
		if(this.point != undefined) {
			shifted_x = this.point.x - this.initGrab.x + this.x;
			shifted_y = this.point.y - this.initGrab.y + this.y;
		}
		setKeyboardPosition(board, grab, shifted_x, shifted_y, 0.12);

		scene.add(grab);
	}
};

var Point = function(x, y) {
	this.start = {
		x: x,
		y: y
	}
	this.x = x;
	this.y = y;
	this.taken = false;
	this.onRelease_callback = function() {};
	this.release = function() {
		this.onRelease_callback();
	};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y) {};
	this.move = function(x, y) {
		this.x = x;
		this.y = y;
		this.onMove_callback(x, y);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	}
};

var apps = [
	'/galaxy.js',
	'/chess.js'
];

var WIDTH = 1200,
  HEIGHT = 800;

var VIEW_ANGLE = 45,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 10000;

var $container = $('#container');

var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
var renderer = new THREE.WebGLRenderer();

camera.position.z = 300;

$container.mousemove(function(event) {
	camera.position.x = -1 * (event.pageX - 300) / 30;
	camera.position.y = (event.pageY - 200) / 30;
});

renderer.setSize(WIDTH, HEIGHT);
$container.append(renderer.domElement);

var redLambert = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
var blueLambert = new THREE.MeshLambertMaterial({ color: 0x0000CC });
var greenLambert = new THREE.MeshLambertMaterial({ color: 0x00CC00 });

var pointLight = new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 50;
pointLight.position.y = 50;
pointLight.position.z = 300;

var directLight = new THREE.DirectionalLight(0xFFFFFF);

directLight.position.x = 0;
directLight.position.y = 0;
directLight.position.z = 1;

//var ambientLight =
//  new THREE.AmbientLight(0xCC0000);

var checkGrab = function(point) {
	if (kM.keyboardApp != null) {
		var objects = kM.keyboardApp.keyboard.objects;
		objects.map(function(object) {
			if (object.available && object.contains(point.x, point.y)) {
				object.registerPoint(point);
				point.taken = true;
			}
		});
	}
}

var scene = new THREE.Scene();

var kM = {
	apps: [],
	front: null,
	back: null,
	front_and_back: null,
	keyboardApp: null,
	points: []
};
kM.State = {
	Normal: 'normal',
	Hidden: 'hidden',
	AppSwitch: 'app-switch',
	Notifications: 'notifications',
	Empty: 'empty'
};
kM.state = kM.State.Normal;

var socket = io.connect('http://162.222.183.103/');
socket.emit('declare-type', 'output');

var device_width = WIDTH;
var device_height = HEIGHT;

socket.on('size', function (data) {
	device_width = JSON.parse(data).width;
	device_height = JSON.parse(data).height;
});

socket.on('code', function (code) {
	screen_code = document.getElementById( 'code' );
	screen_code.innerText = 'Use this code to connect: ' + code;
});

socket.on('start', function (data) {
	var parsed = JSON.parse(data);
	var point = new Point(parsed.x/device_width, 1 - parsed.y/device_height);
	kM.points[parsed.i] = point;
	checkGrab(point);
});

socket.on('move', function (data) {
	var parsed = JSON.parse(data);
	var point = kM.points[parsed.i];
	point.move(parsed.x/device_width, 1 - parsed.y/device_height);
	if (!point.taken) {
		checkGrab(point);
	}
});

socket.on('end', function (data) {
	var parsed = JSON.parse(data);
	kM.points[parsed.i].release(parsed.x/device_width, 1 - parsed.y/device_height);
	kM.points[parsed.i] = {};
});

kM.open = function(app) {
	if (app.external.drawFront != null) {
		//if front and back app has back, push to back
		if (kM.front_and_back != null && kM.front_and_back.external.drawBack != null) {
			kM.back = kM.front_and_back;
		}
		kM.front_and_back = null;
		kM.front = app;
		kM.keyboardApp = app;
	} else if(app.external.drawFrontAndBack) {
		kM.front = null;
		kM.back = null;
		kM.front_and_back = app;
		kM.keyboardApp = app;
	} else if(app.external.drawBack) {
		kM.front_and_back = null;
		kM.back = app;
	}
};

kM.add = function(extern) {
	var app = {};
	app.external = extern;
	app.keyboard = new VRK.Keyboard(app);
	kM.apps.push(app);
	app.external.setUpKeyboard(app.keyboard);
	kM.open(app);
};

kM.minimize = function() {
	if (kM.front_and_back != null && kM.front_and_back.external.drawFront != null) {
		kM.front = kM.front_and_back;
		kM.front_and_back = null;
		kM.keyboardApp = kM.front_and_back;
	}
};
kM.maximize = function() {
	if (kM.front != null && kM.front.external.drawFrontAndBack != null) {
		kM.front_and_back = kM.front;
		kM.front = null;
		kM.back = null;
	}
};

kM.close = function() {
	if (kM.front != null) {
		if (kM.back != null && kM.back.external.drawFrontAndBack != null) {
			kM.front_and_back = kM.back;
			kM.back = null;
		}
		kM.front = null;
		kM.keyboardApp = null;
	} else if (kM.front_and_back != null) {
		kM.front_and_back = null;
		kM.keyboardApp = null;
	} else if (kM.back != null) {
		kM.back = null;
	}
}




/*

Apps can have any set of the three functions f, b, f_b

New apps open at f, if no f, go to fb, if no fb, go to b. Doesn't depend on existing apps.
If existing app conflicts, close, unless was at fb, then go to b if doesn't conflict.

Only can control with keyboard in f and f_b. Maximize and minimize goes between them. App can control this. If you maximize and then minimize, it closes any background app.

Only way to get background app if to be in f_b and open a new f.

=> If you have a b, you must have an fb.

Keyboard top bar:
Left = close. Left button 2 is notifications. Center bar has name and can drag down. Right button max/min. Right button 2 app is app switcher.

*/

kM.drawKeyboard = function(scene) {
	var board = new THREE.Mesh(
		new THREE.PlaneGeometry(80, 30),
		redLambert);

	board.position.x = 0;
	board.position.y = -20;
	board.position.z = 210;
	board.rotation.x = -1.1;

	var greenLambert = new THREE.MeshLambertMaterial({ color: 0x00CC00 });

	var buttonWidth = 1/12;
	var buttonHeight = 1/9;

	switch(kM.state) {
		case kM.State.Normal:
			scene.add(board);
	
			//Draw Top Bar;
			topBar = new THREE.Mesh(
				new THREE.PlaneGeometry(1, buttonHeight),
				greenLambert);

			setKeyboardPosition(board, topBar, 0, buttonHeight * (8 + 1/2), 0.1);
			scene.add(topBar);

			//Draw Keyboard Objects
			if (kM.keyboardApp != null) {
				var objects = kM.keyboardApp.keyboard.objects;
				if (kM.front_and_back != null || kM.front != null) {
					objects.map(function(object) {
						object.draw(scene, board);
					});
				}
			}

			//Draw fingers
			var circle_amplitude = 0.01;
			for (var i = 0; i < kM.points.length; i++) {
				if (kM.points[i] != null && kM.points[i].x != undefined && kM.points[i].y != undefined ) {
					var circle = makeCircle(circle_amplitude);
					setKeyboardPosition(board, circle, kM.points[i].x, kM.points[i].y, 0.15);
					scene.add(circle);
				}
			}
			break;

		case kM.State.Hidden:
			break;

		case kM.State.Notifications:
			scene.add(board);
			break;

		case kM.State.AppSwitch:
			scene.add(board);
			break;

		case kM.State.Empty:
			scene.add(board);

			//Draw Top Bar;
			topBar = new THREE.Mesh(
				new THREE.PlaneGeometry(1, buttonHeight),
				greenLambert);

			setKeyboardPosition(board, topBar, 0, buttonHeight * (8 + 1/2), 0.1);
			scene.add(topBar);
			break;
	}
};

$.getJSON('http://whateverorigin.org/get?url=' + encodeURIComponent('http://162.222.183.103'+apps[0]) + '&callback=?', function(data){
	eval(data.contents);
	kM.add(exports);
});

$.getJSON('http://whateverorigin.org/get?url=' + encodeURIComponent('http://162.222.183.103'+apps[1]) + '&callback=?', function(data){
	eval(data.contents);
	kM.add(exports);
});

/*
kM.open(kM.apps[1]);
kM.open(kM.apps[0]);*/
//kM.maximize();
//kM.minimize();

var render = function() {
	window.requestAnimationFrame(render);

	scene = new THREE.Scene();

	if(kM.front_and_back != null) {
		kM.front_and_back.external.drawFrontAndBack(scene);
	} else {
		if (kM.front != null) {
			kM.front.external.drawFront(scene);
		}
		if (kM.back != null) {
			kM.back.external.drawBack(scene);
		}
	}
	kM.drawKeyboard(scene);

	scene.add(camera);
	scene.add(directLight);
	renderer.render(scene, camera);
};
render();

</script>
</body>
</html>