<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>vOS Demo</title>
</head>
<body>
<script src="http://162.222.183.103/socket.io/socket.io.js"></script>
<script src="http://162.222.183.103/three.min.js"></script>
<script src="http://162.222.183.103/jquery-1.10.1.min.js"></script>
<script src="http://162.222.183.103/utility.js"></script>
<div id="code"></div>
<div id="container"></div>
<script>

var VRK = {};

var makeText = function(text, px, width, height) {
	var canvas1 = document.createElement('canvas');
	canvas1.height = px+10;
	canvas1.width = width * 700;
    var context1 = canvas1.getContext('2d');
    context1.font = "Bold " + px + "px Arial";
    context1.fillStyle = "rgba(255,255,255,0.95)";
    context1.fillText(" " + text, 0, 30);
    var texture1 = new THREE.Texture(canvas1) 
    texture1.needsUpdate = true;
    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
    material1.transparent = true;
    return new THREE.Mesh(new THREE.PlaneGeometry(width, height), material1);
};

VRK.Button = function(x, y, width, height, text, opt_image) {
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.text = text || '';
	this.image = opt_image;
	this.px = 30;
	this.width = width * unitWidth;
	this.height = height * unitHeight;
	this.available = true;
	this.threshold_distance = 0.1;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.point = undefined;
	this.contains = function(x, y) {
		return x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height;
	};
	this.onClick_callback = function(){};
	this.click = function(){
		this.onClick_callback();
	};
	this.onClick = function(callback) {
		this.onClick_callback = callback;
	};
	this.release = function(x, y) {
		if (this.dragDistance() > this.threshold_distance) {
			this.click();
		}
		this.available = true;
		this.point = undefined;
	};
	this.dragDistance = function() {
		if(this.point != undefined) {
			return distance(this.point, this.initGrab);
		}
		return 0;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		this.available = false;
	};
	this.draw = function(scene, board) {
		//change color based on distance
		var distance = this.dragDistance();
		var percentClicked = Math.min(distance/this.threshold_distance, 1);

		var materialOptions = {};
		if (this.point != null) {
			materialOptions.color = (0 << 16) + (200*(1-percentClicked) << 8) + percentClicked*255;
		} else {
			materialOptions.color = (0 << 16) + (200 << 8) + 0;
		}

		var material = new THREE.MeshLambertMaterial(materialOptions);

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);

		var canvas1 = document.createElement('canvas');
		
		if (this.text != '') {
			var contentMesh = makeText(this.text, this.px, this.width, this.height);
		    setKeyboardPosition(board, contentMesh, this.x, this.y, 0.2);
	        scene.add( contentMesh );
		} else if (this.image != undefined) {
	        canvas1.height = 200;
			canvas1.width = 200;
        	var context1 = canvas1.getContext('2d');
       		var texture1 = new THREE.Texture(canvas1) 
			var imageObj = new Image();
	        imageObj.src = this.image;
	        imageObj.onload = function()
	        {
	            context1.drawImage(imageObj, 0, 0);
	            if ( texture1 ) {
	                texture1.needsUpdate = true;
				    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
				    material1.transparent = true;
				    var contentMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material1);
				    setKeyboardPosition(board, contentMesh, this.x, this.y, 0.2);
			        scene.add( contentMesh );
			    }
	        };  
		}
	}
};

VRK.LinearSlider = function(x, y, width, length, returnsToCenter, angle) {
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.width = width * unitWidth;
	this.length = length * unitHeight; //Could get weird when tilted..

	this.grip_width = width;
	this.grip_height = this.grip_width / 3;

	this.progress = 0;

	this.returnsToCenter = returnsToCenter;
	this.angle = angle | 0; //Defaults to sideways

	this.initGrab = {
		x: 0,
		y: 0
	};
	this.available = true;
	this.point = undefined;
	this.getProgress = function() {
		if (this.point != null) {
			this.progress = (Math.sin(this.angle) * this.point.x + Math.cos(this.angle) * this.point.y)/this.length;
		}
		return this.progress;
	}
	this.contains = function(x, y) {
		return false;
	};
	this.onRelease_callback = function(progress) {};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	};
	this.release = function(x, y) {
		this.onRelease_callback(this.getProgress());
		this.available = true;
		this.point = undefined;
	}
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		this.available = false;
	};
	this.onMove_callback = function(progress) {};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	}
	this.move = function(x, y) {
		this.onMove_callback(this.getProgress());
	}
	this.draw = function(scene, board) {
		//Draw line and then draw grip on top.

		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height), material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		//draw this.text;
	};
};

VRK.ArcSlider = function(x, y, returnsToCenter, radius, beginAngle, endAngle) {
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.returnsToCenter = returnsToCenter;
	this.radius = radius;
	this.beginAngle = beginAngle;
	this.endAngle = endAngle;
	this.progress = this.beginAngle;
	
	this.grip_width = 0.5*unitWidth;
	this.grip_height = this.grip_width / 3;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.available = true;
	this.point = undefined;
	this.getProgress = function() {
		if (this.point != null) {
			this.progress = Math.min(Math.max(Math.atan2(this.point.x - this.x, 
				this.point.y - this.y), this.beginAngle), this.endAngle);
		}
		return this.progress;
	}
	this.contains = function(x, y) {
		return false;
	};
	this.onRelease_callback = function(progress) {};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	};
	this.release = function(x, y) {
		this.onRelease_callback(this.getProgress());
		this.available = true;
		this.point = undefined;
	}
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		this.available = false;
	};
	this.onMove_callback = function(progress) {};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	}
	this.move = function(x, y) {
		this.onMove_callback(this.getProgress());
	}
	this.draw = function(scene, board) {
		//Draw line and then draw grip on top.

		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height), material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		//draw this.text;
	};
};


VRK.Treadmill = function(x, y, width, height, options){
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.options = options; //Array of strings

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.width = width * unitWidth;
	this.height = height * unitHeight;
	this.available = true;
	this.max_fingers = 2;//Could modify later to handle more

	this.state = {
		x: 0,
		y: 0,
		angle: 0,
		zoom: 1
	};
	this.startState = {
		x: 0,
		y: 0,
		angle: 0,
		zoom: 1
	};
//	this.initPointPositions = [];
	this.points = [];

	this.contains = function(x, y) {
		return x > this.x && x < this.x + this.width && y > this.y && y < this.y + this.height;
	};
	this.onRelease_callback = function(progress) {};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	};
	this.release = function(x, y, i) {
		this.onRelease_callback(this.state.x, this.state.y, this.state.angle, this.state.zoom);
		this.available = true;
		this.startState = this.state;
		this.points[i] = undefined;
		//find the point and remove it
	};
	this.getTouchAngle = function() {
		if (this.points.length < 2) {
			return 0;
		} else {
			return Math.atan2(this.points[0].x - this.points[1].x, this.points[0].y - this.points[1].y);
		}
	};
	this.getTouchCenter = function() {
		var x = 0;
		var y = 0;

		this.points.map(function(point) {
			if (point != undefined) {
				x += point.x;
				y += point.y;
			}
		});

		return {
			x: x/Math.max(1, this.points.length),
			y: y/Math.max(1, this.points.length)		
		};
	};
	/*this.getInitTouchCenter = function() {
		var x = 0;
		var y = 0;

		this.initPointPositions.map(function(point) {
			x += point.x;
			y += point.y;
		});

		return {
			x: x/Math.max(1, this.initPointPositions.length),
			y: y/Math.max(1, this.initPointPositions.length)		
		};
	};*/
	this.getTouchSeparation = function() {
		if (this.points.length < 2) {
			return 0;
		} else {
			return distance(this.points[0], this.points[1]);
		}
	};
	this.setStartState = function() {
		var center = this.getTouchCenter();
		this.startState = {
			x: center.x,
			y: center.y,
			angle: this.getTouchAngle()
		};
	};
	this.registerPoint = function(point) {
		this.setStartState();
		/*this.initPointPositions[point.i] = {
			x: point.x,
			y: point.y
		};*/
		this.points[point.i] = point;
		point.onRelease(this.release.bind(this));
		point.onMove(this.move.bind(this));
		if (this.points.length >= this.max_fingers)
			this.available = false;
	};
	this.getNewState = function() {
		var newState = {};
		//can calculate new angle and position.
		//new x and y are difference in position vector, then rotated by old angle + angle change.
		newState.angle = this.startState.angle + this.getTouchAngle();
		var disp = vector(this.startState, this.getTouchCenter());
		newState.x = this.startState.x + disp.x * Math.cos(newState.angle) - disp.y * Math.sin(newState.angle);
		newState.y = this.startState.y + disp.x * Math.sin(newState.angle) + disp.y * Math.cos(newState.angle);
		return newState;
	};
	this.onMove_callback = function(x, y, angle, zoom) {};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	};
	this.move = function(x, y, angle, zoom) {
		this.state = this.getNewState();
		console.log(this.state);
		this.onMove_callback(this.state.x, this.state.y, this.state.angle, this.state.zoom);
	};
	this.draw = function(scene, board) {

		//Draw rectangle
		var material = new THREE.MeshLambertMaterial({color: 0x222222});
		treadMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);
		setKeyboardPosition(board, treadMesh, this.x, this.y, 0.1);
		scene.add(treadMesh);


		//Draw Lines to show movement
		//start with vertical lines. Ideally would draw only what is needed. Use modulus.

		//Shift then rotate?

		//Line is a point and a direction. Write function to take it in along with bounds to crop.

	};
};

VRK.Treadmill.option = {
	X: 'x',
	Y: 'y',
	Rotate: 'rotate',
	ZoomIn: 'Zoom In',
	ZoomOut: 'Zoom Out'
};

VRK.Label = function(x, y, width, height, text, px){
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.width = width/12;
	this.height = height/9;
	this.text = text;
	this.px = px || 30;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height), material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
		
		var canvas1 = document.createElement('canvas');
		canvas1.height = this.px;
		canvas1.width = 100;
        var context1 = canvas1.getContext('2d');
        context1.font = "Bold " + this.px + "px Arial";
        context1.fillStyle = "rgba(255,255,255,0.95)";
	    context1.fillText(this.text, 0, this.px);
        var texture1 = new THREE.Texture(canvas1) 
        texture1.needsUpdate = true;
	    var material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } );
	    material1.transparent = true;
	    var textmesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material1);
	    
	    setKeyboardPosition(board, textmesh, this.x, this.y, 0.2);
        scene.add(textmesh);
	};
};

VRK.KeyboardObject = function(x, y, width, height){
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.width = width;
	this.height = height;
	this.contains = function(x, y) {
		return false;
	};
	this.draw = function(scene, board) {
		var material = new THREE.MeshLambertMaterial({color: 0x222222});

		buttonMesh = new THREE.Mesh(
			new THREE.PlaneGeometry(this.width, this.height),
			material);

		setKeyboardPosition(board, buttonMesh, this.x, this.y, 0.1);

		scene.add(buttonMesh);
	};
};

//moves whole keyboard down when dragged. When buttons are pressed, changes state
VRK.SystemBar = function(x, y, width, height){
	var unitWidth = 1/12;
	var unitHeight = 1/9;

	this.x = x * unitWidth;
	this.y = y * unitHeight;
	this.width = width * unitWidth;
	this.height = height * unitHeight;
	this.buttonPosition = {
		'inClose': 0 * unitWidth,
		'inNotifications': 1 * unitWidth,
		'inAppSwitch': 10 * unitWidth,
		'inMaxMin': 11 * unitWidth
	};
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.available = true;
	this.point = undefined;
	this.buttonSelected = undefined;
	this.contains = function(x, y) {
		var which = this.whichButton(x, y);
		return which != 'none';
	};
	this.moving = false;
	this.threshold_distance = 0.1;
	this.whichButton = function(x,y) {
		if (kM.hidden) {
			return 'hideBar';
		} else {
			if (y > this.y) {
				if (x > 2 * unitWidth && x < 10 * unitWidth) {
					return 'hideBar';
				}
				for (state in this.buttonPosition) {
					if (x > this.buttonPosition[state] && x < this.buttonPosition[state] + unitWidth) {
						switch (state) {
							case 'inClose':
								if (kM.getKeyboardApp()) {
									return state;
								}
								break;
							case 'inNotifications':
								return state;
								break;
							case 'inAppSwitch':
								return state;
								break;
							case 'inMaxMin':
								if (kM.canMinimize() || kM.canMaximize()) {
									return state;
								}
								break;
						}
					}
				}
			}
			return 'none';
		}
	}
	this.dragDistance = function() {
		if(this.point != undefined) {
			return distance(this.point, this.initGrab);
		}
		return 0;
	};
	this.release = function(x, y) {
		//if far enough, click.
		if (this.buttonPosition[this.buttonSelected] != undefined && this.dragDistance() > this.threshold_distance) {
			this.click(this.buttonSelected);
		} else if (this.buttonSelected == 'hideBar') {
			if (y > 0.5) {
				kM.hidden = false;
			} else {
				kM.hidden = true;
			}
		}
		this.available = true;
		this.point = undefined;
		this.moving = false;
		this.buttonSelected = 'none';
	};
	this.click = function(buttonName){
		switch(buttonName) {
			case 'inClose':
				if (kM.state == kM.State.Normal) {
					kM.close();
				} else {
					kM.state = kM.State.Normal;
				}
				break;
			case 'inNotifications':
				kM.state = kM.State.Notifications;
				break;
			case 'inAppSwitch':
				kM.state = kM.State.AppSwitch;
				break;
			case 'inMaxMin':
				kM.toggleMaxMin();
				break;
		}
	};
	this.dragDistance = function() {
		if(this.point != undefined) {
			return distance(this.point, this.initGrab);
		}
		return 0;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.buttonSelected = this.whichButton(point.x, point.y);
		if (this.buttonSelected == 'hideBar') {
			this.moving = true;
		}
		this.point = point;
		point.onRelease(this.release.bind(this));
		this.available = false;
	};
	this.draw = function(scene, board) {
		var distance = this.dragDistance();
		var percentClicked = Math.min(distance/this.threshold_distance, 1);

		if (!kM.hidden || this.buttonSelected == 'hideBar') {
			var barMaterial = new THREE.MeshLambertMaterial({color: 0x00CC00});

			var barMesh = new THREE.Mesh(
				new THREE.PlaneGeometry(this.width, this.height), barMaterial);
			
			var adjusted_y = this.y;
			if (kM.hidden) {
				adjusted_y = 0;
				if (this.point != undefined) {
					adjusted_y = this.point.y - this.initGrab.y;
				}
			} else {
				if (this.point != undefined && this.buttonSelected == 'hideBar') {
					adjusted_y = this.y + (this.point.y - this.initGrab.y);
				}
			}

			setKeyboardPosition(board, barMesh, this.x, adjusted_y, 0.1);
			scene.add(barMesh);

			if (this.buttonSelected != 'none' && this.buttonSelected != 'hideBar') {
				//change color based on distance
				setKeyboardPosition(board, barMesh, this.x, adjusted_y, 0.1);
				var materialOptions = {color: 0x00CC00};
				if (this.point != null) {
					materialOptions.color = (0 << 16) + (200 * (1 - percentClicked) << 8) + percentClicked * 255;
				}

				var buttonMaterial = new THREE.MeshLambertMaterial(materialOptions);
				var buttonMesh = new THREE.Mesh(
					new THREE.PlaneGeometry(unitWidth, unitHeight), buttonMaterial);

				setKeyboardPosition(board, buttonMesh, this.x + this.buttonPosition[this.buttonSelected], adjusted_y, 0.11);
				scene.add(buttonMesh);
			}

			if (kM.state == kM.State.Normal) {
				var closeMesh = makeText(' X', 30, unitWidth, unitHeight);
				setKeyboardPosition(board, closeMesh, this.x + this.buttonPosition['inClose'], adjusted_y, 0.12);
				scene.add(closeMesh);

				if (kM.canMaximize()) {
					var maxMinMesh = makeText(' +', 30, unitWidth, unitHeight);
					setKeyboardPosition(board, maxMinMesh, this.x + this.buttonPosition['inMaxMin'], adjusted_y, 0.12);
					scene.add(maxMinMesh);
				} else if (kM.canMinimize()) {
					var maxMinMesh = makeText(' -', 30, unitWidth, unitHeight);
					setKeyboardPosition(board, maxMinMesh, this.x + this.buttonPosition['inMaxMin'], adjusted_y, 0.12);
					scene.add(maxMinMesh);
				}
			} else {
				if (kM.getKeyboardApp() != null) {
					var maxMinMesh = makeText(' <', 30, unitWidth, unitHeight);
					setKeyboardPosition(board, maxMinMesh, this.x + this.buttonPosition['inClose'], adjusted_y, 0.12);
					scene.add(maxMinMesh);
				}
			}
	
			var notificationText = ' !';
			var notifyMesh = makeText(notificationText, 30, unitWidth, unitHeight);
			setKeyboardPosition(board, notifyMesh, this.x + this.buttonPosition['inNotifications'], adjusted_y, 0.12);
			scene.add(notifyMesh);
	
			var appSwitchText = '<->';
			var appSwitchMesh = makeText(appSwitchText, 30, unitWidth, unitHeight);
			setKeyboardPosition(board, appSwitchMesh, this.x + this.buttonPosition['inAppSwitch'], adjusted_y, 0.12);
			scene.add(appSwitchMesh);

			var title = '';
			if (kM.state == kM.State.Normal && kM.getKeyboardApp() != null) {
				title = kM.getKeyboardApp().name;
			} else if (kM.state == kM.State.AppSwitch) {
				title = 'App Switcher';
			} else if (kM.state == kM.State.Notifications) {
				title = 'Notifications';
			}

			var titleMesh = makeText(title, 30, unitWidth*8, unitHeight);
			setKeyboardPosition(board, titleMesh, 2*unitWidth, adjusted_y, 0.12);
			scene.add(titleMesh);
		}
	}
};

//make max draw radius
VRK.Joystick = function(x, y, returnsToCenter) {
	var unitWidth = 1/12;
	var unitHeight = 1/9;
	
	this.x = x * unitWidth;
	this.y = y * unitHeight;

	this.returnsToCenter = returnsToCenter;
	this.initGrab = {
		x: 0,
		y: 0
	};
	this.radius = 0.04;
	this.available = true;
	this.point = undefined;
	this.max_drag = 1/4;
	this.contains = function(x, y) {
		return Math.sqrt(Math.pow(x - this.x,2) + Math.pow((y - this.y) / eccentricity,2)) < this.radius;
	};
	this.release = function(x, y) {
		this.available = true;
		this.onRelease_callback(x - this.x, y - this.y);
		this.point = undefined;
	};
	this.onRelease_callback = function(x, y) {};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y) {};
	this.move = function(x, y){
		this.onMove_callback(x - this.x, y - this.y);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	};
	this.registerPoint = function(point) {
		this.initGrab.x = point.x;
		this.initGrab.y = point.y;
		this.point = point;
		point.onRelease(this.release.bind(this));
		point.onMove(this.move.bind(this));
		this.available = false;
	};
	this.dragDistance = function() {
		if(this.point != undefined) {
			return distance(this.point, this.initGrab);
		}
		return 0;
	};
	this.draw = function(scene, board) {
		var grab = makeFullCircle(this.radius);
		
		var shifted_x = this.x;
		var shifted_y = this.y;
		var scaling_factor = 1;
		if(this.point != undefined) {
			shifted_x = this.point.x - this.initGrab.x + this.x;
			shifted_y = this.point.y - this.initGrab.y + this.y;
			var dist = distance(this.point, this);
			if (dist > this.max_drag) {
				scaling_factor = this.max_drag / dist;
			}
		}

		setKeyboardPosition(board, grab, shifted_x * scaling_factor, shifted_y * scaling_factor, 0.12);

		scene.add(grab);
	};
};

var Point = function(x, y, i) {
	this.start = {
		x: x,
		y: y
	}
	this.x = x;
	this.y = y;
	this.i = i;
	this.taken = false;
	this.onRelease_callback = function() {};
	this.release = function(x, y, i) {
		this.onRelease_callback(x, y, i);
	};
	this.onRelease = function(callback) {
		this.onRelease_callback = callback;
	}
	this.onMove_callback = function(x, y, i) {};
	this.move = function(x, y, i) {
		this.x = x;
		this.y = y;
		this.onMove_callback(x, y, i);
	};
	this.onMove = function(callback) {
		this.onMove_callback = callback;
	}
};

var kM = {
	apps: [],
	front: null,
	back: null,
	front_and_back: null,
	points: []
};

kM.topBar = new VRK.SystemBar(0, 8 + 1/2, 12, 1);

//keyboard is an 8 x 12 grid
VRK.Keyboard = function() {
	this.objects = [kM.topBar];
	this.add = function(object){
		this.objects.push(object);
	};
	this.set = function(array){
		this.objects = array;
		this.objects.push(kM.topBar);
	};
};

var apps = [
	'/stemkoski-vertex-colors.js'
//	,'/stemkoski-Textures.js'
//	,'/stemkoski-Skybox.js'
//	,'/stemkoski-Reflection.js'
//	,'/galaxy.js',
	,'/chess.js'
];

var WIDTH = 1200,
  HEIGHT = 800;

var VIEW_ANGLE = 45,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 10000;

var $container = $('#container');

var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
//THREEx.FullScreen.bindKey({ charCode : 'm'.charCodeAt(0) });
//if ( Detector.webgl )
var renderer = new THREE.WebGLRenderer( {antialias:true} );
//else
//    var renderer = new THREE.CanvasRenderer(); 

camera.position.z = 300;

$container.mousemove(function(event) {
	camera.position.x = -1 * (event.pageX - 300) / 30;
	camera.position.y = (event.pageY - 200) / 30;
});

renderer.setSize(WIDTH, HEIGHT);
$container.append(renderer.domElement);

var pointLight = new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 50;
pointLight.position.y = 50;
pointLight.position.z = 300;

var directLight = new THREE.DirectionalLight(0xFFFFFF);

directLight.position.x = 0;
directLight.position.y = 0;
directLight.position.z = 1;

//var ambientLight =
//  new THREE.AmbientLight(0xCC0000);

var checkGrab = function(point) {
	var keyboardApp = kM.getKeyboardApp();
	if (!kM.topBar.moving) {
		var objects = [];
		switch(kM.state) {
			case kM.State.Normal:
				objects = keyboardApp.keyboard.objects;
				break;
			case kM.State.AppSwitch:
				objects = kM.appSwitcherKeyboard.objects;
				break;
			case kM.State.Notifications:
				objects = kM.notificationKeyboard.objects;
				break;
		}
		objects.map(function(object) {
			if (object.available && object.contains(point.x, point.y)) {
				object.registerPoint(point);
				point.taken = true;
			}
		});
	}
	if (kM.hidden && kM.topBar.available && !point.taken) {
		kM.topBar.registerPoint(point);
		point.taken = true;
	}
}

var scene = new THREE.Scene();

kM.State = {
	Normal: 'normal',
	AppSwitch: 'app-switch',
	Notifications: 'notifications'
};
kM.notificationKeyboard = new VRK.Keyboard();
kM.appSwitcherKeyboard = new VRK.Keyboard();

var setUpNotifications = function() {
	kM.appSwitcherKeyboard.objects = [kM.topBar];
};
setUpNotifications();

var setUpAppSwitcher = function() {
	kM.appSwitcherKeyboard.objects = [kM.topBar];
	var row = 0;
	var column = 0;
	var index = 0;
	var app;

	for (var i = 0; i < kM.apps.length; i++) {
		app = kM.apps[i];
		var icon = new VRK.Button(2 + row * 2, 6 - 2 * column, 1, 1, ' '+i, app.icon);
		icon.onClick((function(index){
			return function(){
				kM.open(kM.apps[index]);
			};
		})(i));
		kM.appSwitcherKeyboard.add(icon);
		if (row >= 4) {
			row = 0;
			column++;
		} else {
			row++;
		}
	}
};
setUpAppSwitcher();

kM.state = kM.State.Normal;

var socket = io.connect('http://162.222.183.103/');
socket.emit('declare-type', 'output');

var device_width = WIDTH;
var device_height = HEIGHT;

socket.on('size', function (data) {
	device_width = JSON.parse(data).width;
	device_height = JSON.parse(data).height;
});

socket.on('code', function (code) {
	screen_code = document.getElementById( 'code' );
	screen_code.innerText = 'Use this code to connect: ' + code;
});

socket.on('start', function (data) {
	var parsed = JSON.parse(data);
	var point = new Point(parsed.x, parsed.y, parsed.i);
	kM.points[parsed.i] = point;
	checkGrab(point);
});

socket.on('move', function (data) {
	var parsed = JSON.parse(data);
	var point = kM.points[parsed.i];
	point.move(parsed.x, parsed.y, parsed.i);
	if (!point.taken) {
		checkGrab(point);
	}
});

socket.on('end', function (data) {
	var parsed = JSON.parse(data);
	kM.points[parsed.i].release(parsed.x, parsed.y, parsed.i);
	kM.points[parsed.i] = {};
});

kM.open = function(app) {
	if (app.external.drawFront != null) {
		//if front and back app has back, push to back
		if (kM.front_and_back != null && kM.front_and_back.external.drawBack != null) {
			kM.back = kM.front_and_back;
		}
		kM.front_and_back = null;
		kM.front = app;
	} else if(app.external.drawFrontAndBack) {
		kM.front = null;
		kM.back = null;
		kM.front_and_back = app;
	} else if(app.external.drawBack) {
		kM.front_and_back = null;
		kM.back = app;
	}
	kM.state = kM.State.Normal;
};

kM.add = function(extern) {
	var app = {};
	app.external = extern;
	app.keyboard = new VRK.Keyboard(app);
	app.name = extern.name;
	app.icon = extern.icon;
	kM.apps.push(app);
	app.external.setUpKeyboard(app.keyboard);
	kM.open(app);
};

kM.canMaximize = function() {
	return kM.front != null && kM.front.external.drawFrontAndBack != null;
};

kM.canMinimize = function() {
	return kM.front_and_back != null && kM.front_and_back.external.drawFront != null;
};

kM.getKeyboardApp = function() {
	if (kM.front != null) {
		return kM.front;
	} else if (kM.front_and_back != null) {
		return kM.front_and_back;
	} 
	return null;
}

kM.minimize = function() {
	if (kM.canMinimize()) {
		kM.front = kM.front_and_back;
		kM.front_and_back = null;
	}
};

kM.maximize = function() {
	if (kM.canMaximize()) {
		kM.front_and_back = kM.front;
		kM.front = null;
		kM.back = null;
	}
};

kM.toggleMaxMin = function() {
	if (kM.front != null) {
		kM.maximize();
	} else if(kM.front_and_back != null) {
		kM.minimize();
	}
};

kM.close = function() {
	if (kM.front != null) {
		if (kM.back != null && kM.back.external.drawFrontAndBack != null) {
			kM.front_and_back = kM.back;
			kM.back = null;
		}
		kM.front = null;
	} else if (kM.front_and_back != null) {
		kM.front_and_back = null;
	} else if (kM.back != null) {
		kM.back = null;
	}
	if (kM.front == null && kM.front_and_back == null) {
		kM.state = kM.State.AppSwitch;
	}
}


/*

Apps can have any set of the three functions f, b, f_b

New apps open at f, if no f, go to fb, if no fb, go to b. Doesn't depend on existing apps.
If existing app conflicts, close, unless was at fb, then go to b if doesn't conflict.

Only can control with keyboard in f and f_b. Maximize and minimize goes between them. App can control this. If you maximize and then minimize, it closes any background app.

Only way to get background app if to be in f_b and open a new f.

=> If you have a b, you must have an fb.

*/

var oldState = kM.State.Normal;

kM.drawKeyboard = function(scene) {
	var redLambert = new THREE.MeshLambertMaterial({ color: 0xCC0000 });

	var board = new THREE.Mesh(
		new THREE.PlaneGeometry(80, 30),
		redLambert);

	board.position.x = 0;
	board.position.y = -20;
	board.position.z = 210;
	board.rotation.x = -1.1;

	var unitWidth = 1/12;
	var unitHeight = 1/9;

	var keyboardApp = kM.getKeyboardApp();

	if (kM.hidden) {
		//To unhide, drag up at least a threshold and show bar rising from bottom. Jump on let go.
		kM.topBar.draw(scene, board);
	} else {
		if (kM.topBar.moving) {
			kM.topBar.draw(scene, board);
		} else {
			var objects = [];
			switch(kM.state) {
				case kM.State.Normal:
					if (keyboardApp != null) {
						objects = keyboardApp.keyboard.objects;
					}
					break;
				case kM.State.Notifications:
					if (oldState != kM.state) {
						setUpNotifications();
					}
					objects = kM.notificationKeyboard.objects;
					break;
				case kM.State.AppSwitch:
					if (oldState != kM.state) {
						setUpAppSwitcher();
					}
					objects = kM.appSwitcherKeyboard.objects;
					break;
			}
			oldState = kM.state;
			objects.map(function(object) {
				object.draw(scene, board);
			});

			scene.add(board);
			var circle_amplitude = 0.01;
			for (var i = 0; i < kM.points.length; i++) {
				if (kM.points[i] != null && kM.points[i].x != undefined && kM.points[i].y != undefined ) {
					var circle = makeCircle(circle_amplitude);
					setKeyboardPosition(board, circle, kM.points[i].x, kM.points[i].y, 0.15);
					scene.add(circle);
				}
			}
		}
	}
};


apps.map(function(appURL) {
	var url = 'http://whateverorigin.org/get?url=' + encodeURIComponent('http://162.222.183.103'+appURL) + '&callback=?';
/*	var url = 'http://162.222.183.103'+appURL;
	$.getScript(url, function() {
		kM.add(exports);
	});*/
	$.getJSON(url, function(data){
		eval(data.contents); //Find way to sanitize this.
		kM.add(exports);
	});
});
/*
$.getJSON('http://whateverorigin.org/get?url=' + encodeURIComponent('http://162.222.183.103'+apps[1]) + '&callback=?', function(data){
	eval(data.contents);
	kM.add(exports);
});
*/
/*
kM.open(kM.apps[1]);
kM.open(kM.apps[0]);*/
//kM.maximize();
//kM.minimize();

var render = function() {
	window.requestAnimationFrame(render);

	scene = new THREE.Scene();

	if(kM.front_and_back != null) {
		kM.front_and_back.external.drawFrontAndBack(scene);
	} else {
		if (kM.front != null) {
			kM.front.external.drawFront(scene);
		}
		if (kM.back != null) {
			kM.back.external.drawBack(scene);
		}
	}
	kM.drawKeyboard(scene);

	scene.add(camera);
	scene.add(directLight);
	renderer.render(scene, camera);
};
render();

</script>
</body>
</html>