<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8"> 
	<title>Three JS Demo</title>
</head>
<body>
<script src="file://localhost/Users/Gavin/Google%20Drive/Development/VR-Keyboard/public/three.min.js"></script>
<script src="file://localhost/Users/Gavin/Google%20Drive/Development/VR-Keyboard/public/jquery-1.10.1.min.js"></script>
<div id="container"></div>
<script>
//Required for apps
var  VRK = {};
//keyboard is an 8 x 12 grid
var Button = function(x, y, width, height) {
	this.x = x;
	this.y = y;
	this.width = width;
	this.height = height;
};
Button.prototype.onClick = function(callback) {
	this.onClick_callback = callback;
}

VRK.Button = Button;

</script>

<script>
var chess = {};
chess.drawFront = function(scene) {
	var redLambert = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
	
	var cube = new THREE.Mesh(
		new THREE.CubeGeometry(10, 20, 30),
		redLambert);

	cube.rotation.x = Math.PI/4;
	cube.rotation.y = 0.3;

	scene.add(cube);

	/* var screen = new THREE.Mesh(
			new THREE.PlaneGeometry(80, 80),
			greenLambert);

		screen.position.x = 0;
		screen.position.y = 15;
		screen.position.z = 140;

		scene.add(screen); */
};
/*chess.drawBack = function(scene) {
	
	
};*/
chess.drawFrontAndBack = function(scene) {
	chess.drawFront(scene);
//	chess.drawBack(scene);
};
chess.setUpKeyboard = function(keyboard) {
	var left = new VRK.Button(1, 3, 1, 1);
	var right = new VRK.Button(3, 3, 1, 1);
	var up = new VRK.Button(2, 4, 1, 1);
	var down = new VRK.Button(2, 2, 1, 1);

	keyboard.add(left);
	keyboard.add(right);
	keyboard.add(up);
	keyboard.add(down);

	left.onClick(function() {
		console.log('left click');
	});
}

var export1 = chess;
</script>


<script>
var galaxy = {};
galaxy.setUpKeyboard = function(keyboard) {
	var right = new VRK.Button(8, 1, 2, 1);
	keyboard.add(right);
	right.onClick(function() {
		console.log('right click');
	});
}
/*galaxy.drawFront = function(scene) {

};*/
galaxy.drawBack = function(scene) {
	var blueLambert = new THREE.MeshLambertMaterial({ color: 0x0000CC });
	var radius = 20,
    segments = 16,
    rings = 16;

	var sphere = new THREE.Mesh(
	  new THREE.SphereGeometry(
	    radius,
	    segments,
	    rings),
	  blueLambert);

	var angle = (Date.now()%5000)/5000*2*Math.PI;
	sphere.position.x = 200*Math.cos(angle);
	sphere.position.y = 40;

	sphere.position.z = 100+200*Math.sin(angle);

	scene.add(sphere);
};
galaxy.drawFrontAndBack = function(scene) {
//	galaxy.drawFront(scene);
	galaxy.drawBack(scene);
};

export2 = galaxy;
</script>

<script>
var WIDTH = 600,
  HEIGHT = 400;

var VIEW_ANGLE = 45,
  ASPECT = WIDTH / HEIGHT,
  NEAR = 0.1,
  FAR = 10000;

var $container = $('#container');

var camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);
var renderer = new THREE.WebGLRenderer();

camera.position.z = 300;

$container.mousemove(function(event) {
	camera.position.x = -1 * (event.pageX - 300) / 30;
	camera.position.y = (event.pageY - 200) / 30;
});

renderer.setSize(WIDTH, HEIGHT);
$container.append(renderer.domElement);

var redLambert = new THREE.MeshLambertMaterial({ color: 0xCC0000 });
var blueLambert = new THREE.MeshLambertMaterial({ color: 0x0000CC });
var greenLambert = new THREE.MeshLambertMaterial({ color: 0x00CC00 });

var pointLight = new THREE.PointLight(0xFFFFFF);

pointLight.position.x = 50;
pointLight.position.y = 50;
pointLight.position.z = 300;

var directLight = new THREE.DirectionalLight(0xFFFFFF);

directLight.position.x = 0;
directLight.position.y = 0;
directLight.position.z = 1;

//var ambientLight =
//  new THREE.AmbientLight(0xCC0000);

var scene = new THREE.Scene();

var kM = {
	apps: [],
	front: null,
	back: null,
	front_and_back: null
};

kM.add = function(extern) {
	var app = {
		external: extern,
		keyboard: {
			buttons: [],
			add: function(button){
				app.keyboard.buttons.push(button);
			}
		}
	};
	kM.apps.push(app);
	app.external.setUpKeyboard(app.keyboard);
};

kM.open = function(app) {
	if (app.external.drawFront != null) {
		//if front and back app has back, push to back
		if (kM.front_and_back != null && kM.front_and_back.external.drawBack != null) {
			kM.back = kM.front_and_back;
		}
		kM.front_and_back = null;
		kM.front = app;
	} else if(app.external.drawFrontAndBack) {
		kM.front = null;
		kM.back = null;
		kM.front_and_back = app;
	} else if(app.external.drawBack) {
		kM.front_and_back = null;
		kM.back = app;
	}
};
kM.minimize = function() {
	if (kM.front_and_back != null && kM.front_and_back.external.drawFront != null) {
		kM.front = kM.front_and_back;
		kM.front_and_back = null;
	}
};
kM.maximize = function() {
	if (kM.front != null && kM.front.external.drawFrontAndBack != null) {
		kM.front_and_back = kM.front;
		kM.front = null;
		kM.back = null;
	}
};

kM.close = function() {
	if (kM.front != null) {
		if (kM.back != null && kM.back.external.drawFrontAndBack != null) {
			kM.front_and_back = kM.back;
			kM.back = null;
		}
		kM.front = null;
	} else if (kM.front_and_back != null) {
		kM.front_and_back = null;
	} else if (kM.back != null) {
		kM.back = null;
	}
}

kM.points = [];

kM.start = function(update) {
	kM.points[update.i] = {
		start: {
			x: update.x,
			y: update.y},
		x: update.x,
		y: update.y
	};
};

kM.move = function(update) {
	kM.points[update.i].x = update.x;
	kM.points[update.i].y = update.y;

	//check kM.screenApp.buttons
};
kM.end = function(update) {
	kM.points[update.i] = {};

	//check kM.screenApp.buttons
	//if so, activate them.
};

//Handle points relative to size.
kM.start(
{
	i: 0,
	x: 0.5,
	y: 0.5
});

kM.start(
{
	i: 1,
	x: 0.2,
	y: 0.5
});

/*

Apps can have any set of the three functions f, b, f_b

New apps open at f, if no f, go to fb, if no fb, go to b. Doesn't depend on existing apps.
If existing app conflicts, close, unless was at fb, then go to b if doesn't conflict.

Only can control with keyboard in f and f_b. Maximize and minimize goes between them. App can control this. If you maximize and then minimize, it closes any background app.

Only way to get background app if to be in f_b and open a new f.

=> If you have a b, you must have an fb.


Keyboard top bar:
left = close. Center bar has name and can drag down. Right button max/min. Right button 2 app is app switcher.

*/


kM.drawKeyboard = function(scene) {
	var board = new THREE.Mesh(
		new THREE.PlaneGeometry(80, 30),
		redLambert);

	board.position.x = 0;
	board.position.y = -20;
	board.position.z = 210;
	board.rotation.x = -1.1;

	scene.add(board);

	var buttonWidth = board.geometry.width/12;
	var buttonHeight = board.geometry.height/9;

	var buttonMesh;

	var buttons;
	if (kM.front_and_back != null) {
		buttons = kM.front_and_back.keyboard.buttons;
	} else if (kM.front != null) {
		buttons = kM.front.keyboard.buttons;
	}

	topBar = new THREE.Mesh(
		new THREE.PlaneGeometry(board.geometry.width, buttonHeight),
		greenLambert);

	//var x_displacement = buttonWidth * (buttons[i].x + buttons[i].width/2) - board.geometry.width/2;
	var y_displacement = buttonHeight * (8 + 1/2) - board.geometry.height/2;
	var z_displacement = 0.1;

	topBar.position.x = 0;
	topBar.position.y = board.position.y + y_displacement * Math.cos(board.rotation.x) - z_displacement * Math.sin(board.rotation.x);
	topBar.position.z = board.position.z + y_displacement * Math.sin(board.rotation.x) + z_displacement * Math.cos(board.rotation.x);

	topBar.rotation.x = board.rotation.x;
	scene.add(topBar);

	if (kM.front_and_back != null || kM.front != null) {
		for(var i = 0; i < buttons.length; i++) {
			buttonMesh = new THREE.Mesh(
				new THREE.PlaneGeometry(buttonWidth*buttons[i].width, buttonHeight*buttons[i].height),
				greenLambert);

			var x_displacement = buttonWidth * (buttons[i].x + buttons[i].width/2) - board.geometry.width/2;
			var y_displacement = buttonHeight * (buttons[i].y + buttons[i].height/2) - board.geometry.height/2;
			var z_displacement = 0.1;

			buttonMesh.position.x = board.position.x + x_displacement;
			buttonMesh.position.y = board.position.y + y_displacement * Math.cos(board.rotation.x) - z_displacement * Math.sin(board.rotation.x);
			buttonMesh.position.z = board.position.z + y_displacement * Math.sin(board.rotation.x) + z_displacement * Math.cos(board.rotation.x);

			buttonMesh.rotation.x = board.rotation.x;
			scene.add(buttonMesh);
		}
	}

	var circle_geometry;
	var greenLine = new THREE.LineBasicMaterial({color: 0x999999});

	var circle_resolution = 40;
	var circle_amplitude = 1;

	for (var i = 0; i < kM.points.length; i++) {
		if (kM.points[i] != null && kM.points[i].x != undefined && kM.points[i].y != undefined ) {
			circle_geometry = new THREE.Geometry();
			for(var j = 0; j <= circle_resolution; j++) {
				var theta = (j / circle_resolution) * Math.PI * 2;

				var x_displacement = kM.points[i].x * board.geometry.width + circle_amplitude * Math.cos(theta) - board.geometry.width / 2;
				var y_displacement = kM.points[i].y * board.geometry.height + circle_amplitude * Math.sin(theta) - board.geometry.height / 2;
				var z_displacement = 0.15;

				circle_geometry.vertices.push( new THREE.Vector3(
						board.position.x + x_displacement, 
						board.position.y + y_displacement * Math.cos(board.rotation.x) - z_displacement * Math.sin(board.rotation.x),
						board.position.z + y_displacement * Math.sin(board.rotation.x) + z_displacement * Math.cos(board.rotation.x)
				));
				scene.add(new THREE.Line(circle_geometry, greenLine));
			}
		}
	}
};

kM.add(export1);
kM.add(export2);

kM.open(kM.apps[1]);
kM.open(kM.apps[0]);
//kM.maximize();
//kM.minimize();

var render = function() {
	window.requestAnimationFrame(render);

	scene = new THREE.Scene();

	if(kM.front_and_back != null) {
		kM.front_and_back.external.drawFrontAndBack(scene);
	} else {
		if (kM.front != null) {
			kM.front.external.drawFront(scene);
		}
		if (kM.back != null) {
			kM.back.external.drawBack(scene);
		}
	}
	kM.drawKeyboard(scene);

	scene.add(camera);
	scene.add(directLight);
	renderer.render(scene, camera);
};
render();

</script>
</body>
</html>