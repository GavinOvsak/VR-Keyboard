// Generated by CoffeeScript 1.7.1
var controlObjects, eccentricity, exports;

eccentricity = 80 / 30;

if (typeof exports === "undefined" || exports === null) {
  controlObjects = {};
  exports = controlObjects;
}

exports.setUp = function(state, util) {
  var controls;
  controls = {};
  controls.Object = function(x, y, width, height, options) {
    var method;
    this.x = (x || 0) * state.unitWidth;
    this.y = (y || 0) * state.unitHeight;
    this.width = (width || 1) * state.unitWidth;
    this.height = (height || 1) * state.unitHeight;
    this.options = options || {};
    for (method in controls.Object.prototype) {
      this[method] = controls.Object.prototype[method];
    }
    return void 0;
  };
  controls.Object.prototype = {
    setX: function(x) {
      return this.x = x;
    },
    setY: function(y) {
      return this.y = y;
    },
    setWidth: function(width) {
      return this.width = width;
    },
    setHeight: function(height) {
      return this.height = height;
    },
    updateOptions: function(options) {
      var option, value, _results;
      _results = [];
      for (option in options) {
        value = options[option];
        _results.push(this.options[option] = value);
      }
      return _results;
    }
  };
  controls.Button = function() {
    controls.Object.apply(this, arguments);
    this.applyDefaults();
    return void 0;
  };
  controls.Button.prototype = {
    applyDefaults: function() {
      var defaultOptions, key, option;
      defaultOptions = {
        text_size: 30,
        text: '',
        toggle: false
      };
      if (this.options == null) {
        this.options = {};
      }
      for (key in defaultOptions) {
        option = defaultOptions[key];
        if (this.options[key] == null) {
          this.options[key] = option;
        }
      }
      this.initGrab = {
        x: 0,
        y: 0
      };
      this.point = void 0;
      return this.isOn = false;
    },
    thickness: 0.1,
    available: true,
    contains: function(x, y) {
      return (this.x < x && x < this.x + this.width) && (this.y < y && y < this.y + this.height);
    },
    onClick_callback: function(isOn) {},
    click: function(isOn) {
      return this.onClick_callback(isOn);
    },
    onClick: function(callback) {
      return this.onClick_callback = callback;
    },
    release: function(x, y) {
      this.available = true;
      if (this.contains(this.point.x, this.point.y)) {
        this.click(!this.isOn);
        if (this.options.toggle) {
          this.isOn = !this.isOn;
        }
      }
      return this.point = void 0;
    },

    /*
    		dragDistance: ->
    			if(this.point?) {
    				return util.distance(this.point, this.initGrab)
    			}
    			return 0
    		},
     */
    registerPoint: function(point) {
      this.initGrab.x = point.x;
      this.initGrab.y = point.y;
      this.point = point;
      point.onRelease(this.release.bind(this));
      return this.available = false;
    },
    draw: function() {
      var buttonMesh, canvas1, contentMesh, material, materialOptions, meshArray, px;
      meshArray = [];
      materialOptions = {};
      if (this.isOn) {
        if (this.point != null) {
          if (this.contains(this.point.x, this.point.y)) {
            materialOptions.color = 200;
          } else {
            materialOptions.color = (100 << 16) + (100 << 8) + 100;
          }
        } else {
          materialOptions.color = 200 << 8;
        }
      } else {
        if (this.point != null) {
          if (this.contains(this.point.x, this.point.y)) {
            materialOptions.color = 200 << 8;
          } else {
            materialOptions.color = (100 << 16) + (100 << 8) + 100;
          }
        } else {
          materialOptions.color = 200;
        }
      }
      material = new THREE.MeshBasicMaterial(materialOptions);
      buttonMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material);
      buttonMesh.position.x = this.x;
      buttonMesh.position.y = this.y;
      buttonMesh.position.z = 0.05;
      meshArray.push(buttonMesh);
      canvas1 = document.createElement('canvas');
      px = this.options.text_size;
      if (this.options.text !== '') {
        contentMesh = util.makeText(this.options.text, px, this.width, this.height);
        contentMesh.position.x = this.x;
        contentMesh.position.y = this.y;
        contentMesh.position.z = 0.1;
        meshArray.push(contentMesh);
      }

      /*
      			else if this.options.image?
      				canvas1.height = 200
      				canvas1.width = 200
      				context1 = canvas1.getContext('2d')
      				texture1 = new THREE.Texture(canvas1) 
      				imageObj = new Image()
      				imageObj.src = this.options.image
      				imageObj.onload = ->
       */

      /*
               context1.drawImage(imageObj, 0, 0)
               if ( texture1 ) {
      				texture1.needsUpdate = true
      				material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } )
      				material1.transparent = true
      				contentMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material1)
      				util.setPanelPosition(panelMesh, contentMesh, this.x, this.y, 0.2)
      				scene.add( contentMesh )
      			}
       */
      return meshArray;
    }
  };
  controls.LinearSlider = function() {
    controls.Object.apply(this, arguments);
    this.applyDefaults();
    return void 0;
  };
  controls.LinearSlider.direction = {
    VERTICAL: 'vertical',
    HORIZONTAL: 'horizontal'
  };
  controls.LinearSlider.prototype = {
    applyDefaults: function() {
      var defaultOptions, key, option;
      defaultOptions = {
        direction: controls.LinearSlider.direction.VERTICAL,
        returnsToCenter: false,
        initProgress: 0.5
      };
      if (this.options == null) {
        this.options = {};
      }
      for (key in defaultOptions) {
        option = defaultOptions[key];
        if (this.options[key] == null) {
          this.options[key] = option;
        }
      }
      this.line_width = 0.1;
      this.grip_height = 0.5;
      this.progress = this.options.initProgress;
      return this.initGrab = {
        x: 0,
        y: 0,
        progress: 0
      };
    },
    available: true,
    point: void 0,
    thickness: 0.1,
    getProgress: function() {
      if (this.progress == null) {
        this.progress = this.options.initProgress || 0.5;
      }
      if (this.point != null) {
        if (this.options.direction === controls.LinearSlider.direction.VERTICAL) {
          this.progress = this.initGrab.progress + (this.point.y - this.initGrab.y) / (this.height - this.grip_height * state.unitHeight);
        } else if (this.options.direction === controls.LinearSlider.direction.HORIZONTAL) {
          this.progress = this.initGrab.progress + (this.point.x - this.initGrab.x) / (this.width - this.grip_height * state.unitWidth);
        }
      }
      this.progress = Math.max(Math.min(this.progress, 1), 0);
      return this.progress;
    },
    contains: function(x, y) {
      if (this.options.direction === controls.LinearSlider.direction.VERTICAL) {
        return x > this.x && x < this.x + this.width && y > this.y + (this.height - this.grip_height * state.unitHeight) * this.progress && y < this.y + (this.height - this.grip_height * state.unitHeight) * this.progress + this.grip_height * state.unitHeight;
      } else if (this.options.direction === controls.LinearSlider.direction.HORIZONTAL) {
        return y > this.y && y < this.y + this.height && x > this.x + (this.width - this.grip_height * state.unitWidth) * this.progress && x < this.x + (this.width - this.grip_height * state.unitWidth) * this.progress + this.grip_height * state.unitWidth;
      }
    },
    onRelease_callback: function(progress) {},
    onRelease: function(callback) {
      return this.onRelease_callback = callback;
    },
    setProgress: function(progress) {
      return this.progress = progress;
    },
    release: function(x, y) {
      this.onRelease_callback(this.getProgress());
      if (this.options.returnsToCenter) {
        this.progress = 0.5;
      }
      this.available = true;
      return this.point = void 0;
    },
    onMove_callback: function(progress) {},
    onMove: function(callback) {
      return this.onMove_callback = callback;
    },
    move: function(x, y) {
      return this.onMove_callback(this.getProgress());
    },
    registerPoint: function(point) {
      this.initGrab.x = point.x;
      this.initGrab.y = point.y;
      this.initGrab.progress = this.progress;
      this.point = point;
      point.onRelease(this.release.bind(this));
      point.onMove(this.move.bind(this));
      return this.available = false;
    },
    draw: function() {
      var gripMesh, grip_material, line, line_material, meshArray;
      meshArray = [];
      line_material = new THREE.MeshBasicMaterial({
        color: 0x222222
      });
      grip_material = new THREE.MeshBasicMaterial({
        color: 0x224222
      });
      if (this.options.direction === controls.LinearSlider.direction.VERTICAL) {
        line = new THREE.Mesh(new THREE.PlaneGeometry(this.line_width * state.unitWidth, this.height), line_material);
        line.position.x = this.x + (this.width - this.line_width * state.unitWidth) / 2;
        line.position.y = this.y;
        line.position.z = 0.05;
        gripMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.grip_height * state.unitHeight), grip_material);
        gripMesh.position.x = this.x;
        gripMesh.position.y = this.y + (this.height - this.grip_height * state.unitHeight) * this.progress;
        gripMesh.position.z = 0.1;
      } else if (this.options.direction === controls.LinearSlider.direction.HORIZONTAL) {
        line = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.line_width * state.unitHeight), line_material);
        line.position.x = this.x;
        line.position.y = this.y + (this.height - this.line_width * state.unitHeight) / 2;
        line.position.z = 0.05;
        gripMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.grip_height * state.unitWidth, this.height), grip_material);
        gripMesh.position.x = this.x + (this.width - this.grip_height * state.unitWidth) * this.progress;
        gripMesh.position.y = this.y;
        gripMesh.position.z = 0.1;
      }
      meshArray.push(line);
      meshArray.push(gripMesh);
      return meshArray;
    }
  };
  controls.Treadmill = function() {
    controls.Object.apply(this, arguments);
    this.applyDefaults();
    return void 0;
  };
  controls.Treadmill.prototype = {
    applyDefaults: function() {
      var defaultOptions, key, option, _results;
      defaultOptions = {
        x: false,
        y: false,
        rotate: false,
        zoom: false,
        zoomIn: false,
        zoomOut: false
      };
      this.options = this.options || {};
      _results = [];
      for (key in defaultOptions) {
        option = defaultOptions[key];
        if (this.options[key] == null) {
          _results.push(this.options[key] = option);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    thickness: 0.1,
    available: true,
    max_fingers: 2,
    state: {
      x: 0,
      y: 0,
      angle: 0,
      zoom: 1
    },
    startState: {
      x: 0,
      y: 0,
      angle: 0,
      zoom: 1
    },
    grabInfo: {
      x: 0,
      y: 0,
      angle: 0,
      zoom: 1
    },
    points: [],
    cloneState: function(state) {
      return {
        x: state.x,
        y: state.y,
        angle: state.angle,
        zoom: state.zoom
      };
    },
    contains: function(x, y) {
      return (this.x < x && x < this.x + this.width) && (this.y < y && y < this.y + this.height);
    },
    onRelease_callback: function(x, y, angle, zoom) {},
    onRelease: function(callback) {
      return this.onRelease_callback = callback;
    },
    release: function(x, y, i) {
      this.onRelease_callback(this.state.x, this.state.y, this.state.angle, this.state.zoom);
      this.available = true;
      this.startState = {
        x: this.state.x,
        y: this.state.y,
        angle: this.state.angle,
        zoom: this.state.zoom
      };
      this.points[i] = void 0;
      return this.setGrabInfo();
    },
    getTouchAngle: function() {
      if (this.getNumPoints() < 2) {
        return 0;
      } else if ((this.points[0] != null) && (this.points[1] != null)) {
        return Math.atan2(this.points[0].x - this.points[1].x, this.points[0].y - this.points[1].y);
      }
      return 0;
    },
    getTouchCenter: function() {
      var point, x, y, _i, _len, _ref;
      x = 0;
      y = 0;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        if (point != null) {
          x += point.x;
          y += point.y;
        }
      }
      return {
        x: x / Math.max(1, this.getNumPoints()),
        y: y / Math.max(1, this.getNumPoints())
      };
    },
    getNumPoints: function() {
      var counter, point, _i, _len, _ref;
      counter = 0;
      _ref = this.points;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        point = _ref[_i];
        counter += (point != null) && (point.x != null) && (point.y != null) ? 1 : 0;
      }
      return counter;
    },
    getTouchSeparation: function() {
      if (this.getNumPoints() < 2) {
        return 1;
      } else if ((this.points[0] != null) && (this.points[1] != null)) {
        return util.distance(this.points[0], this.points[1]);
      }
    },
    setGrabInfo: function() {
      var center;
      center = this.getTouchCenter();
      return this.grabInfo = {
        x: center.x,
        y: center.y,
        angle: this.getTouchAngle(),
        zoom: this.getTouchSeparation()
      };
    },
    registerPoint: function(point) {
      this.startState = this.cloneState(this.state);
      this.points[point.i] = point;
      this.setGrabInfo();
      point.onRelease(this.release.bind(this));
      point.onMove(this.move.bind(this));
      if (this.getNumPoints() >= this.max_fingers) {
        return this.available = false;
      }
    },
    getNewState: function() {
      var disp, newState;
      newState = this.cloneState(this.startState);
      if (this.options.rotate) {
        newState.angle = this.startState.angle + this.getTouchAngle() - this.grabInfo.angle;
      }
      disp = util.vector(this.getTouchCenter(), this.grabInfo);
      if (this.options.x != null) {
        newState.x = this.startState.x + disp.x * Math.cos(newState.angle) - disp.y * Math.sin(newState.angle);
      }
      if (this.options.y != null) {
        newState.y = this.startState.y + disp.x * Math.sin(newState.angle) + disp.y * Math.cos(newState.angle);
      }
      if (this.options.zoom || (this.options.zoomIn && this.grabInfo.zoom > this.getTouchSeparation()) || (this.options.zoomOut && this.grabInfo.zoom < this.getTouchSeparation())) {
        newState.zoom = this.startState.zoom * this.grabInfo.zoom / this.getTouchSeparation();
      }
      return newState;
    },
    onMove_callback: function(x, y, angle, zoom) {},
    onMove: function(callback) {
      return this.onMove_callback = callback;
    },
    move: function(x, y, i) {
      this.state = this.getNewState();
      return this.onMove_callback(this.state.x, this.state.y, this.state.angle, this.state.zoom);
    },
    draw: function() {
      var material, meshArray, treadMesh;
      meshArray = [];
      material = new THREE.MeshBasicMaterial({
        color: 0x222222
      });
      treadMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material);
      treadMesh.position.x = this.x;
      treadMesh.position.y = this.y;
      treadMesh.position.z = 0.1;
      meshArray.push(treadMesh);
      return meshArray;
    }
  };
  controls.Label = function() {
    controls.Object.apply(this, arguments);
    this.applyDefaults();
    return void 0;
  };
  controls.Label.prototype = {
    available: false,
    applyDefaults: function() {
      var defaultOptions, key, option, _results;
      defaultOptions = {
        text: '',
        px: 30
      };
      if (this.options == null) {
        this.options = {};
      }
      _results = [];
      for (key in defaultOptions) {
        option = defaultOptions[key];
        if (this.options[key] == null) {
          _results.push(this.options[key] = option);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    thickness: 0.1,
    contains: function(x, y) {
      return false;
    },
    draw: function() {
      var buttonMesh, material, meshArray, textMesh;
      meshArray = [];
      material = new THREE.MeshBasicMaterial({
        color: 0x222222
      });
      buttonMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material);
      buttonMesh.position.x = this.x;
      buttonMesh.position.y = this.y;
      buttonMesh.position.z = 0.05;
      meshArray.push(buttonMesh);
      textMesh = util.makeText(this.options.text, this.options.px, this.width, this.height);

      /*
      			canvas1 = document.createElement('canvas')
      			canvas1.height = this.options.px
      			canvas1.width = this.options.px * this.width / this.height
      			context1 = canvas1.getContext('2d')
      			context1.font = "Bold " + this.options.px + "px Arial"
      			context1.fillStyle = "rgba(255,255,255,0.95)"
      			context1.fillText(this.options.text, 0, this.options.px)
      			texture1 = new THREE.Texture(canvas1) 
      			texture1.needsUpdate = true
      			material1 = new THREE.MeshBasicMaterial( {map: texture1, side:THREE.DoubleSide } )
      			material1.transparent = true
      			textMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), material1)
       */
      textMesh.position.x = this.x;
      textMesh.position.y = this.y;
      textMesh.position.z = 0.1;
      meshArray.push(textMesh);
      return meshArray;
    }
  };
  controls.Keyboard = function() {
    controls.Object.apply(this, arguments);
    this.applyDefaults();
    return void 0;
  };
  controls.Keyboard.prototype = {
    gestureThresholdDistance: 0.2,
    available: true,
    applyDefaults: function() {
      var defaultOptions, key, option, _results;
      defaultOptions = {
        startText: ''
      };
      this.points = [];
      this.text = '';
      this.gesturePoint = void 0;
      this.shifted = true;
      this.makeKeys();
      if (this.options == null) {
        this.options = {};
      }
      _results = [];
      for (key in defaultOptions) {
        option = defaultOptions[key];
        if (this.options[key] == null) {
          _results.push(this.options[key] = option);
        } else {
          _results.push(void 0);
        }
      }
      return _results;
    },
    thickness: 0.1,
    makeKey: function(getChar, x, y, width, height, apply) {
      var keyboard;
      keyboard = this;
      return {
        apply: apply,
        getChar: getChar,
        x: x,
        y: y,
        width: width,
        height: height,
        toString: function() {
          return this.getChar();
        },
        contains: function(x, y) {

          /*
          					heigh: 0.17777777777777778
          					keyx: 0.6466
          					keyy: 0.2607111111111111
          					letter: "M"
          					wid: 0.075
          					x: 0.6510417
          					y: 0.2777778
           */

          /*
          					console.log({
          						x: x,
          						y: y,
          						keyx: this.x * keyboard.width + keyboard.x,
          						keyy: this.y * keyboard.height + keyboard.y,
          						wid: this.width * keyboard.width,
          						heigh: this.height * keyboard.height,
          						letter: this.char,
          						bool: util.rectContains(x, y, 
          						this.x * keyboard.width + keyboard.x, 
          						this.y * keyboard.height + keyboard.y, 
          						this.width * keyboard.width, this.height * keyboard.height)
          					})
           */
          return util.rectContains({
            x: x,
            y: y
          }, this.x * keyboard.width + keyboard.x, this.y * keyboard.height + keyboard.y, this.width * keyboard.width, this.height * keyboard.height);
        }
      };
    },
    initPoint: function(point) {
      var initKey;
      initKey = this.getKey(point.x, point.y);
      this.points[point.i] = {
        key: void 0,
        gesturing: false,
        trail: [],
        keyTrails: [],
        dragDist: function() {
          if (this.initGrab) {
            return util.distance(this, this.initGrab);
          } else {
            return 0;
          }
        },
        update: function(x, y, key) {
          if (key && !this.initGrab) {
            this.initGrab = {
              x: x,
              y: y,
              key: key
            };
          }
          if (this.x !== x || this.y !== y) {
            this.x = x;
            this.y = y;
            this.trail.push({
              x: this.x,
              y: this.y
            });
            if (this.key !== key) {
              if (this.keyTrails.length !== 0) {
                this.keyTrails[this.keyTrails.length - 1].trailEnd = this.trail.length;
              }
              if (key != null) {
                this.keyTrails.push({
                  key: key,
                  trailStart: this.trail.length
                });
              }
            }
            return this.key = key;
          }
        }
      };
      this.points[point.i].update(point.x, point.y, initKey);
      if (initKey != null) {
        return this.points[point.i].initGrab = {
          x: point.x,
          y: point.y,
          key: initKey
        };
      }
    },
    makeKeys: function() {
      var board;
      board = this;
      return this.keys = [
        this.makeKey((function() {
          if (board.shifted) {
            return 'Q';
          } else {
            return 'q';
          }
        }), 0.0083, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'W';
          } else {
            return 'w';
          }
        }), 0.0975, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'E';
          } else {
            return 'e';
          }
        }), 0.1866, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'R';
          } else {
            return 'r';
          }
        }), 0.2775, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'T';
          } else {
            return 't';
          }
        }), 0.3666, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'Y';
          } else {
            return 'y';
          }
        }), 0.4566, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'U';
          } else {
            return 'u';
          }
        }), 0.5466, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'I';
          } else {
            return 'i';
          }
        }), 0.6375, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'O';
          } else {
            return 'o';
          }
        }), 0.7266, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'P';
          } else {
            return 'p';
          }
        }), 0.8166, 0.785, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'A';
          } else {
            return 'a';
          }
        }), 0.0516, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'S';
          } else {
            return 's';
          }
        }), 0.1416, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'D';
          } else {
            return 'd';
          }
        }), 0.2325, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'F';
          } else {
            return 'f';
          }
        }), 0.3225, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'G';
          } else {
            return 'g';
          }
        }), 0.4116, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'H';
          } else {
            return 'h';
          }
        }), 0.5016, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'J';
          } else {
            return 'j';
          }
        }), 0.5916, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'K';
          } else {
            return 'k';
          }
        }), 0.6825, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'L';
          } else {
            return 'l';
          }
        }), 0.7725, 0.5366, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return '\\\/';
          } else {
            return '^';
          }
        }), 0.0166, 0.2933, 0.075, 0.2, function(text) {
          board.shifted = !board.shifted;
          return text;
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'Z';
          } else {
            return 'z';
          }
        }), 0.1066, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'X';
          } else {
            return 'x';
          }
        }), 0.1966, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'C';
          } else {
            return 'c';
          }
        }), 0.2866, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'V';
          } else {
            return 'v';
          }
        }), 0.3766, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'B';
          } else {
            return 'b';
          }
        }), 0.4675, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'N';
          } else {
            return 'n';
          }
        }), 0.5575, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          if (board.shifted) {
            return 'M';
          } else {
            return 'm';
          }
        }), 0.6466, 0.2933, 0.075, 0.2, function(text) {
          return text + this.getChar();
        }), this.makeKey((function() {
          return 'Space';
        }), 0.2866, 0.045, 0.435, 0.2, function(text) {
          return text + ' ';
        }), this.makeKey((function() {
          return '<-';
        }), 0.905, 0.7833, 0.0833, 0.2, function(text) {
          if (text.length > 0) {
            return text.substring(0, text.length - 1);
          } else {
            return text;
          }
        })
      ];
    },
    getKey: function(x, y) {
      var i, key, _ref;
      _ref = this.keys;
      for (i in _ref) {
        key = _ref[i];
        if (key.contains(x, y)) {
          return key;
        }
      }
    },
    contains: function(x, y) {
      return (this.x < x && x < this.x + this.width) && (this.y < y && y < this.y + this.height);
    },
    getText: function() {
      return this.options.text;
    },
    setText: function(text) {
      if (Object.prototype.toString.call(text) === '[object String]') {
        this.options.text = text;
      }
      return this.options.text;
    },
    registerPoint: function(point) {
      this.initPoint(point);
      point.onRelease(this.release.bind(this));
      return point.onMove(this.move.bind(this));
    },
    release: function(x, y, i) {
      var bestScore, bestWord, curvatures, data, keySequence, segment, suggestions, trail, trailEnd, trailStart, _i, _j, _len, _ref, _ref1;
      if (this.gesturePoint === this.points[i]) {
        keySequence = '';
        curvatures = [];
        _ref = this.gesturePoint.keyTrails;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          trail = _ref[_i];
          trailStart = trail.trailStart;
          trailEnd = trail.trailEnd;
          segment = this.gesturePoint.trail.slice(trailStart, trailEnd);
          keySequence += trail.key.getChar();
          data = segment.map(function(n) {
            return [n.x, n.y];
          });
          curvatures.push(1 / ss.r_squared(data, ss.linear_regression().data(data).line()));
        }
        suggestions = util.get_suggestion(state, keySequence, curvatures);
        console.log(suggestions);
        bestWord = '';
        bestScore = 0;
        for (i = _j = 0, _ref1 = suggestions.length; 0 <= _ref1 ? _j < _ref1 : _j > _ref1; i = 0 <= _ref1 ? ++_j : --_j) {
          if (suggestions[i].score > bestScore) {
            bestScore = suggestions[i].score;
            bestWord = suggestions[i].word;
          }
        }
        if (((bestWord != null ? bestWord[0] : void 0) != null) && this.shifted) {
          bestWord = bestWord[0].toUpperCase() + bestWord.slice(1);
          this.shifted = false;
        }
        if (this.text.length !== 0) {
          this.text = this.text + ' ' + bestWord;
        } else {
          this.text = bestWord;
        }
        this.onTextUpdate_callback(this.text);
        this.gesturePoint = void 0;
      } else if (this.getKey(x, y) != null) {
        this.text = this.getKey(x, y).apply(this.text);
        this.onTextUpdate_callback(this.text);
      }
      console.log(this.text);
      this.points[i] = void 0;
      if (this.points.length === 0) {
        return this.gesturePoint = void 0;
      }
    },
    move: function(x, y, i) {
      this.points[i].update(x, y, this.getKey(x, y));
      if (!this.gesturePoint && this.points[i].dragDist() > this.gestureThresholdDistance) {
        this.gesturePoint = this.points[i];
        return this.gesturePoint.gesturing = true;
      }
    },
    onTextUpdate_callback: function(text) {},
    onTextUpdate: function(callback) {
      return this.onTextUpdate_callback = callback;
    },
    draw: function() {
      var contentMesh, gestureGeometry, gestureLine, greyLine, key, keyMaterial, keyMaterialOptions, keyMesh, material, meshArray, point, _i, _j, _len, _len1, _ref, _ref1;
      meshArray = [];
      material = new THREE.MeshBasicMaterial({
        color: 0x222222
      });

      /*			
      			progress = {}
      			for (i in this.points) {
      				if (this.points[i] and this.points[i].initGrab and this.points[i] isnt this.gesturePoint)
      					progress[this.points[i].initGrab.key] = Math.min(this.points[i].dragDist()/this.thresholdDistance, 1)
      			}
       */
      _ref = this.keys;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        key = _ref[_i];
        keyMaterialOptions = {
          color: 0x222222
        };

        /*if (progress[key.char]) {
        					keyMaterialOptions.color = (34 << 16) + (200 * 0 << 8) + (1 - progress[key.char]) * 255
        				}
         */
        keyMaterial = new THREE.MeshBasicMaterial(keyMaterialOptions);
        keyMesh = new THREE.Mesh(new THREE.PlaneGeometry(key.width * this.width, key.height * this.height), keyMaterial);
        keyMesh.position.x = key.x * this.width + this.x;
        keyMesh.position.y = key.y * this.height + this.y;
        keyMesh.position.z = 0.05;
        meshArray.push(keyMesh);
        contentMesh = util.makeText(key.getChar(), 30, key.width * this.width, key.height * this.height);
        contentMesh.position.x = key.x * this.width + this.x;
        contentMesh.position.y = key.y * this.height + this.y;
        contentMesh.position.z = 0.08;
        meshArray.push(contentMesh);
      }
      if (this.gesturePoint) {
        greyLine = new THREE.LineBasicMaterial({
          color: 0x999999,
          linewidth: 2
        });
        gestureGeometry = new THREE.Geometry();
        _ref1 = this.gesturePoint.trail;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          point = _ref1[_j];
          gestureGeometry.vertices.push(new THREE.Vector3(point.x, point.y, 0));
        }
        gestureLine = new THREE.Line(gestureGeometry, greyLine);
        gestureLine.position.x = this.x;
        gestureLine.position.y = this.y;
        gestureLine.position.z = 0.1;
        meshArray.push(gestureLine);
      }
      return meshArray;
    }
  };
  controls.Joystick = function() {
    controls.Object.apply(this, arguments);
    this.applyDefaults();
    return void 0;
  };
  controls.Joystick.prototype = {
    applyDefaults: function() {
      var defaultOptions, key, option;
      if (this.options.radius != null) {
        this.max_drag = this.options.radius * state.unitWidth;
      } else {
        this.max_drag = 1 / 4;
      }
      defaultOptions = {
        returnsToCenter: true
      };
      if (this.options == null) {
        this.options = {};
      }
      for (key in defaultOptions) {
        option = defaultOptions[key];
        if (this.options[key] == null) {
          this.options[key] = option;
        }
      }
      return this.initGrab = {
        x: 0,
        y: 0
      };
    },
    thickness: 0.1,
    radius: 0.04,
    available: true,
    point: void 0,
    contains: function(x, y) {
      return Math.sqrt(Math.pow(x - this.x, 2) + Math.pow((y - this.y) / eccentricity, 2)) < this.radius;
    },
    release: function(x, y) {
      this.available = true;
      this.onRelease_callback(x - this.x, y - this.y);
      return this.point = void 0;
    },
    onRelease_callback: function(x, y) {},
    onRelease: function(callback) {
      return this.onRelease_callback = callback;
    },
    onMove_callback: function(x, y) {},
    move: function(x, y) {
      var dist, scaling_factor_x, scaling_factor_y, x_shift, y_shift;
      scaling_factor_x = 1;
      scaling_factor_y = 1;
      x_shift = this.point.x - this.initGrab.x;
      y_shift = this.point.y - this.initGrab.y;
      dist = util.length({
        x: this.point.x - this.x,
        y: (this.point.y - this.y) / eccentricity
      });
      if (dist > this.max_drag) {
        scaling_factor_x = this.max_drag / dist;
        scaling_factor_y = this.max_drag / dist;
      }
      return this.onMove_callback(x_shift * scaling_factor_x, y_shift * scaling_factor_y);
    },
    onMove: function(callback) {
      return this.onMove_callback = callback;
    },
    registerPoint: function(point) {
      this.initGrab.x = point.x;
      this.initGrab.y = point.y;
      this.point = point;
      point.onRelease(this.release.bind(this));
      point.onMove(this.move.bind(this));
      return this.available = false;
    },
    dragDistance: function() {
      if (this.point != null) {
        return util.distance(this.point, this.initGrab);
      }
      return 0;
    },
    draw: function() {
      var dist, grab, meshArray, scaling_factor_x, scaling_factor_y, x_shift, y_shift;
      meshArray = [];
      grab = util.makeFullCircle(this.radius);
      x_shift = 0;
      y_shift = 0;
      scaling_factor_x = 1;
      scaling_factor_y = 1;
      if (this.point != null) {
        x_shift = this.point.x - this.initGrab.x;
        y_shift = this.point.y - this.initGrab.y;
        dist = util.length({
          x: this.point.x - this.x,
          y: (this.point.y - this.y) / eccentricity
        });
        if (dist > this.max_drag) {
          scaling_factor_x = this.max_drag / dist;
          scaling_factor_y = this.max_drag / dist;
        }
      }
      grab.position.x = this.x + x_shift * scaling_factor_x;
      grab.position.y = this.y + y_shift * scaling_factor_y;
      grab.position.z = 0.1;
      meshArray.push(grab);
      return meshArray;
    }
  };
  controls.Panel = function() {
    this.objects = [];
    this.add = function(object) {
      return this.objects.push(object);
    };
    this.set = function(array) {
      return this.objects = array;
    };
    return void 0;
  };
  state.topBar = {
    x: 0,
    y: 1 - state.unitHeight,
    width: 1,
    height: state.unitHeight,
    buttonPosition: {
      'inClose': 0 * state.unitWidth,
      'inSettings': 1 * state.unitWidth,
      'inAppSwitch': 10 * state.unitWidth,
      'inMaxMin': 11 * state.unitWidth
    },
    initGrab: {
      x: 0,
      y: 0
    },
    thickness: 0.1,
    available: true,
    point: void 0,
    buttonSelected: void 0,
    contains: function(x, y) {
      var which;
      which = this.whichButton(x, y);
      return which !== 'none';
    },
    state: 'overlay',
    whichButton: function(x, y) {
      var option, position, _ref;
      if (this.state !== 'moving' && (this.y < y && y < this.y + this.height)) {
        if (x > 2 * state.unitWidth && x < 10 * state.unitWidth) {
          return 'hideBar';
        }
        _ref = this.buttonPosition;
        for (option in _ref) {
          position = _ref[option];
          if ((position < x && x < position + state.unitWidth)) {
            switch (option) {
              case 'inClose':
                if (state.getPanelApp()) {
                  return option;
                }
                break;
              case 'inSettings':
                return option;
              case 'inAppSwitch':
                return option;
              case 'inMaxMin':
                if (state.canMinimize() || state.canMaximize()) {
                  return option;
                }
            }
          }
        }
      }
      return 'none';
    },
    dragDistance: function() {
      if (this.point != null) {
        return util.distance(this.point, this.initGrab);
      }
      return 0;
    },
    release: function(x, y) {
      if ((this.buttonPosition[this.buttonSelected] != null) && util.rectContains(this.point, this.buttonPosition[this.buttonSelected], this.y, 1, this.height)) {
        this.click(this.buttonSelected);
      } else if (this.buttonSelected === 'hideBar') {
        if (y > 0.5) {
          this.state = 'overlay';
        } else {
          this.state = 'mobile';
        }
      }
      this.available = true;
      this.point = void 0;
      return this.buttonSelected = 'none';
    },
    click: function(buttonName) {
      switch (buttonName) {
        case 'inClose':
          if (state.mode === state.modes.AppSwitch && (state.back != null) && (state.front == null)) {
            state.front_and_back = state.back;
            state.back = null;
          }
          if (state.mode === state.modes.Normal) {
            return state.close();
          } else {
            return state.mode = state.modes.Normal;
          }
          break;
        case 'inSettings':
          return state.mode = state.modes.Settings;
        case 'inAppSwitch':
          state.mode = state.modes.AppSwitch;
          if (state.front_and_back != null) {
            state.back = state.front_and_back;
            return state.front_and_back = null;
          }
          break;
        case 'inMaxMin':
          return state.toggleMaxMin();
      }
    },
    dragDistance: function() {
      if (this.point != null) {
        return util.distance(this.point, this.initGrab);
      }
      return 0;
    },
    registerPoint: function(point) {
      var pt, _i, _len, _ref;
      this.initGrab.x = point.x;
      this.initGrab.y = point.y;
      this.buttonSelected = this.whichButton(point.x, point.y);
      if (this.buttonSelected === 'hideBar') {
        this.state = 'moving';
        _ref = state.points;
        for (_i = 0, _len = _ref.length; _i < _len; _i++) {
          pt = _ref[_i];
          if ((pt.i != null) && pt.i !== point.i) {
            state.points[pt.i].release(pt.x, pt.y, pt.i);
            pt.taken = false;
          }
        }
      }
      this.point = point;
      point.onRelease(this.release.bind(this));
      return this.available = false;
    },
    draw: function() {
      var adjusted_y, appSwitchMesh, appSwitchText, barMaterial, barMesh, buttonMaterial, buttonMesh, closeMesh, materialOptions, maxMinMesh, meshArray, notificationText, notifyMesh, title, titleMesh;
      meshArray = [];
      barMaterial = new THREE.MeshBasicMaterial({
        color: 0x00CC00
      });
      barMesh = new THREE.Mesh(new THREE.PlaneGeometry(this.width, this.height), barMaterial);
      switch (this.state) {
        case 'moving':
          adjusted_y = this.y + (this.point.y - this.initGrab.y);
          break;
        case 'mobile':
          this.y = 0;
          adjusted_y = this.y;
          break;
        case 'overlay':
          this.y = 1 - state.unitHeight;
          adjusted_y = this.y;
      }
      barMesh.position.x = this.x;
      barMesh.position.y = adjusted_y;
      barMesh.position.z = 0.05;
      meshArray.push(barMesh);
      if (this.buttonSelected !== 'none' && this.buttonSelected !== 'hideBar') {
        materialOptions = {
          color: 0x00CC00
        };
        if (this.point != null) {
          if (util.rectContains(this.point, this.buttonPosition[this.buttonSelected], this.y, 1, this.height)) {
            materialOptions.color = 255;
          } else {
            materialOptions.color = (100 << 16) + (100 << 8) + 100;
          }
        } else {
          materialOptions.color = 200 << 8;
        }
        buttonMaterial = new THREE.MeshBasicMaterial(materialOptions);
        buttonMesh = new THREE.Mesh(new THREE.PlaneGeometry(state.unitWidth, state.unitHeight), buttonMaterial);
        buttonMesh.position.x = this.x + this.buttonPosition[this.buttonSelected];
        buttonMesh.position.y = adjusted_y;
        buttonMesh.position.z = 0.08;
        meshArray.push(buttonMesh);
      }
      if (state.mode === state.modes.Normal) {
        closeMesh = util.makeText(' X', 30, state.unitWidth, state.unitHeight);
        closeMesh.position.x = this.x + this.buttonPosition['inClose'];
        closeMesh.position.y = adjusted_y;
        closeMesh.position.z = 0.1;
        meshArray.push(closeMesh);
        if (state.canMaximize()) {
          maxMinMesh = util.makeText(' +', 30, state.unitWidth, state.unitHeight);
          maxMinMesh.position.x = this.x + this.buttonPosition['inMaxMin'];
          maxMinMesh.position.y = adjusted_y;
          maxMinMesh.position.z = 0.1;
          meshArray.push(maxMinMesh);
        } else if (state.canMinimize()) {
          maxMinMesh = util.makeText(' -', 30, state.unitWidth, state.unitHeight);
          maxMinMesh.position.x = this.x + this.buttonPosition['inMaxMin'];
          maxMinMesh.position.y = adjusted_y;
          maxMinMesh.position.z = 0.1;
          meshArray.push(maxMinMesh);
        }
      } else {
        if (state.getPanelApp() != null) {
          maxMinMesh = util.makeText(' <', 30, state.unitWidth, state.unitHeight);
          maxMinMesh.position.x = this.x + this.buttonPosition['inClose'];
          maxMinMesh.position.y = adjusted_y;
          maxMinMesh.position.z = 0.1;
          meshArray.push(maxMinMesh);
        }
      }
      notificationText = ' *';
      notifyMesh = util.makeText(notificationText, 30, state.unitWidth, state.unitHeight);
      notifyMesh.position.x = this.x + this.buttonPosition['inSettings'];
      notifyMesh.position.y = adjusted_y;
      notifyMesh.position.z = 0.1;
      meshArray.push(notifyMesh);
      appSwitchText = '<->';
      appSwitchMesh = util.makeText(appSwitchText, 30, state.unitWidth, state.unitHeight);
      appSwitchMesh.position.x = this.x + this.buttonPosition['inAppSwitch'];
      appSwitchMesh.position.y = adjusted_y;
      appSwitchMesh.position.z = 0.1;
      meshArray.push(appSwitchMesh);
      title = '';
      if (state.mode === state.modes.Normal && (state.getPanelApp() != null)) {
        title = state.getPanelApp().name;
      } else if (state.mode === state.modes.AppSwitch) {
        title = 'App Switcher';
      } else if (state.mode === state.modes.Settings) {
        title = 'Settings';
      }
      titleMesh = util.makeText(title, 30, state.unitWidth * 8, state.unitHeight);
      titleMesh.position.x = 2 * state.unitWidth;
      titleMesh.position.y = adjusted_y;
      titleMesh.position.z = 0.1;
      meshArray.push(titleMesh);
      return meshArray;
    }
  };
  state.addURL = function(url, extras, open) {
    return (function(state, controls, appURL, util) {

      /*
      	      window.testApps[appID] = {
      	        event: {}
      	      }
      	      util.getSync(appURL, (data, textStatus, jqxhr) ->
      	        ((vOS, program) ->
      	            eval(program)
      	        )({
      	          onEvent: (eventType, f) ->
      	            window.testApps[appID].event[eventType] = f
      	          makeTextMesh: (options) ->
      	            return {} #To Do
      	        })
      	        if window.testApps[appID].event.load?
      	          state.add(window.testApps[appID], controls)
      	        else
      	          console.log('App from ' + appURL + ' Failed To Load')
      	      )
       */
      window.vOS = {
        onEvent: function(eventType, f) {
          return this.app.event[eventType] = f;
        },
        getValues: function() {
          return state.values;
        },
        makeTextMesh: function(options) {
          var height, px, text, width;
          text = options.text || '';
          px = options.px || 30;
          width = options.width || 20;
          height = options.height || 20;
          return util.makeText(text, px, width, height);
        },
        getValue: function(name) {
          return state.values[name];
        },
        addListener: function(name, f) {
          if (state.valueListeners[name] == null) {
            state.valueListeners[name] = [];
          }
          return state.valueListeners[name].push(f);
        },
        removeListener: function(name, f) {
          var index;
          index = state.valueListeners[name].indexOf(f);
          if (index > -1) {
            return state.valueListeners[name].pop(index);
          }
        },
        app: {
          event: {}
        }
      };
      return util.getScriptSync(appURL, function(data, textStatus, jqxhr) {
        var app, k, v;
        if (vOS.app.event.load != null) {
          if (extras != null) {
            for (k in extras) {
              v = extras[k];
              vOS.app[k] = v;
            }
            app = state.add(vOS.app, controls);
            if (open) {
              state.open(app, controls);
            }
          }
        } else {
          console.log('App from ' + appURL + ' Failed To Load');
        }
        return window.vOS.app = {
          event: {}
        };
      });
    })(state, controls, url, util);
  };
  return controls;
};
