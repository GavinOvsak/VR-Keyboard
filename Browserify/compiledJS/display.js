// Generated by CoffeeScript 1.7.1
var display;

display = exports;

display.start = function(state, util, controls) {
  var $viewer, ASPECT, FAR, HMDRotation, NEAR, OculusRift, USE_TRACKER, VIEW_ANGLE, WORLD_FACTOR, cardBoardLight, cardboardCamera, cardboardControls, cardboardEffect, centerHeading, count, directLight, e, effect, keyboardMoveVector, moveVector, navList, once, pointLight, projGeo, projMaterial, render, resize, setOrientationControls, setUiSize, wasUsingRift;
  VIEW_ANGLE = 45;
  ASPECT = state.width / state.height;
  NEAR = 0.1;
  FAR = 100000;
  count = 0;
  once = false;
  cardboardControls = null;
  $viewer = $('#viewer');
  if ((typeof isCardboard !== "undefined" && isCardboard !== null) && isCardboard) {
    VIEW_ANGLE = 90;
  }
  state.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  /*
  	contained apps should stay in x: -50,50 y: 150,250 z: -50,50
   */
  state.camera.rotation.x = Math.PI / 2;
  state.camera.position.y = 0;
  state.camera.position.z = 10;
  try {
    state.renderer = new THREE.WebGLRenderer({
      antialias: true,
      alpha: true
    });
  } catch (_error) {
    e = _error;
    alert('This application needs WebGL enabled!');
    return false;
  }
  state.renderer.autoClearColor = true;
  state.renderer.setSize(state.width, state.height);
  $viewer.append(state.renderer.domElement);
  if ((typeof isCardboard !== "undefined" && isCardboard !== null) && isCardboard) {
    state.renderer.domElement.addEventListener('click', function(e) {
      return util.toggleFullScreen();
    }, false);
  }
  state.mobileCamera = new THREE.OrthographicCamera(0, 1, 1, 0, -30, 30);
  state.mobileCamera.position.z = 10;
  state.mobileCamera.up = new THREE.Vector3(0, 1, 0);
  state.mobileRenderer = new THREE.WebGLRenderer({
    antialias: true,
    alpha: true
  });
  state.mobileRenderer.autoClearColor = true;
  state.mobileRenderer.setSize(400, 400);
  pointLight = new THREE.PointLight(0xFFFFFF);
  pointLight.position.x = 50;
  pointLight.position.y = 50;
  pointLight.position.z = 300;
  directLight = new THREE.DirectionalLight(0xFFFFFF);
  directLight.position.x = 0;
  directLight.position.y = 0;
  directLight.position.z = 1;
  USE_TRACKER = false;
  WORLD_FACTOR = 1.0;
  OculusRift = {
    hResolution: 1280,
    vResolution: 800,
    hScreenSize: 0.14976,
    vScreenSize: 0.0936,
    interpupillaryDistance: 0.064,
    lensSeparationDistance: 0.064,
    eyeToScreenDistance: 0.041,
    distortionK: [1.0, 0.22, 0.24, 0.0],
    chromaAbParameter: [0.996, -0.004, 1.014, 0.0]
  };
  centerHeading = 0;
  navList = [];
  moveVector = new THREE.Vector3();
  keyboardMoveVector = new THREE.Vector3();
  HMDRotation = new THREE.Quaternion();
  OculusRift.hResolution = state.width;
  OculusRift.vResolution = state.height;
  effect = new THREE.OculusRiftEffect(state.renderer, {
    HMD: OculusRift,
    worldFactor: WORLD_FACTOR
  });
  effect.setSize(state.width, state.height);
  cardboardEffect = new THREE.StereoEffect(state.renderer);
  cardboardEffect.separation = 0.06;
  cardboardCamera = new THREE.PerspectiveCamera(90, 1, 0.001, 700);
  cardboardCamera.position.set(0, 10, 0);
  cardBoardLight = new THREE.HemisphereLight(0x777777, 0x000000, 0.6);
  cardboardControls = new THREE.DeviceOrientationControls(state.camera, true);
  setUiSize = function() {
    var height, hwidth, width;
    width = window.innerWidth;
    hwidth = width / 2;
    return height = window.innerHeight;
  };
  resize = function(event) {
    state.width = window.innerWidth;
    state.height = window.innerHeight;
    setUiSize();
    ASPECT = state.width / state.height;
    OculusRift.hResolution = state.width;
    OculusRift.vResolution = state.height;
    effect.setHMD(OculusRift);
    state.camera.projectionMatrix.makePerspective(VIEW_ANGLE, ASPECT, NEAR, FAR);
    state.camera.updateProjectionMatrix();
    state.renderer.setSize(state.width, state.height);
    effect.setSize(state.width, state.height);
    return cardboardEffect.setSize(state.width, state.height);
  };
  window.addEventListener('resize', resize, false);
  resize();
  projGeo = new THREE.SphereGeometry(5000, 512, 256);
  projMaterial = new THREE.MeshBasicMaterial({
    map: THREE.ImageUtils.loadTexture('static/placeholder.png'),
    side: THREE.DoubleSide
  });
  wasUsingRift = false;

  /*
  	setOrientationControls = (e) ->
  		if !e.alpha
  			console.log('gone')
  			return
  
  		console.log('Set up')
  		cardboardControls = new THREE.DeviceOrientationControls(state.camera, true)
  		console.log(state.camera.quaternion)
  		console.log(state.camera.rotation)
  		debugger
  		 *element.addEventListener('click', fullscreen, false)
  
  		window.removeEventListener('deviceorientation', setOrientationControls)
  	window.addEventListener('deviceorientation', setOrientationControls, true)
   */
  setOrientationControls = function(event) {
    if (event.alpha) {
      window.removeEventListener('deviceorientation', setOrientationControls, false);
      cardboardControls.connect();
      return cardboardControls.update();
    }
  };
  window.addEventListener('deviceorientation', setOrientationControls, false);
  render = function() {
    var adjustedHMDQuarternion, matr, matr2, scene, tilt, tilt2;
    requestAnimationFrame(render);
    moveVector.add(keyboardMoveVector);
    if (USE_TRACKER || (state.vr != null)) {
      moveVector.x = 0;
    }
    state.BaseRotationEuler.set(0.0, util.angleRangeRad(state.BaseRotationEuler.y + moveVector.y), 0.0);
    state.BaseRotation.setFromEuler(state.BaseRotationEuler);
    matr = new THREE.Matrix4();
    matr.makeRotationFromQuaternion(state.BaseRotation);
    tilt = new THREE.Matrix4();
    tilt.makeRotationX(Math.PI / 2);
    matr.multiplyMatrices(tilt, matr);
    state.BaseRotation.setFromRotationMatrix(matr);
    adjustedHMDQuarternion = new THREE.Quaternion();
    adjustedHMDQuarternion.x = HMDRotation.x;
    adjustedHMDQuarternion.y = HMDRotation.y;
    adjustedHMDQuarternion.z = HMDRotation.z;
    adjustedHMDQuarternion.w = HMDRotation.w;
    matr2 = new THREE.Matrix4();
    matr2.makeRotationFromQuaternion(adjustedHMDQuarternion);
    tilt2 = new THREE.Matrix4();
    tilt2.makeRotationX(0 * Math.PI / 2);
    matr2.multiplyMatrices(tilt2, matr2);
    adjustedHMDQuarternion.setFromRotationMatrix(matr2);
    if (!((typeof isCardboard !== "undefined" && isCardboard !== null) && isCardboard)) {
      state.camera.quaternion.multiplyQuaternions(state.BaseRotation, adjustedHMDQuarternion);
    }
    scene = new THREE.Scene();
    if (state.front_and_back != null) {
      (function() {
        return state.front_and_back.external.drawImmersive(scene);
      })();
    } else {
      switch (state.mode) {
        case state.modes.Normal:
          if (state.front != null) {
            (function() {
              return state.front.external.drawContained(scene);
            })();
          }
          break;
        case state.modes.AppSwitch:
          state.appSwitcher.external.drawContained(scene);
      }
      if (state.back != null) {
        (function() {
          if (state.back.external.drawImmersiveBackground != null) {
            return state.back.external.drawImmersiveBackground(scene);
          } else if (state.back.external.drawImmersive != null) {
            return state.back.external.drawImmersive(scene);
          }
        })();
      }
    }
    state.drawPanel(scene, util);
    scene.add(directLight);

    /*
    		hudCamera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR)
    		hudCamera.rotation.x = Math.PI/2
    		hudCamera.position.y = 0
    		hudCamera.position.z = 10
    		hudCamera.quaternion.multiplyQuaternions(state.BaseRotation, adjustedHMDQuarternion)
     */
    scene.add(state.camera);
    if ((typeof isCardboard !== "undefined" && isCardboard !== null) && isCardboard) {
      cardboardCamera.updateProjectionMatrix();
      cardboardControls.update();
      return cardboardEffect.render(scene, state.camera);
    } else {
      if (Date.now() - state.lastUpdate < 100 || state.forceDistort) {
        effect.render(scene, state.camera);
        return wasUsingRift = true;
      } else {
        HMDRotation.x = 0;
        HMDRotation.y = 0;
        HMDRotation.z = 0;
        HMDRotation.w = 1;
        if (wasUsingRift) {
          state.BaseRotationEuler.y = 0;
        }
        state.renderer.setViewport(0, 0, state.width, state.height);
        state.renderer.render(scene, state.camera);
        return wasUsingRift = false;
      }
    }

    /*
    		count++
    		if state.mirrorViews.indexOf('HUD') > -1 and count % 5 is 0
    			state.socket.emit('mirror', {
    				view: 'HUD',
    				image: state.renderer.domElement.toDataURL()
    			})
     */
  };
  setUiSize();
  return render();
};
