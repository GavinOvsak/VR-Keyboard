// Generated by CoffeeScript 1.7.1
var display;

display = exports;

display.start = function(state, util, controls) {
  var $viewer, ASPECT, FAR, HMDRotation, NEAR, OculusRift, USE_TRACKER, VIEW_ANGLE, WORLD_FACTOR, centerHeading, currHeading, directLight, e, effect, headingVector, keyboardMoveVector, moveVector, navList, pointLight, projGeo, projMaterial, render, renderer, resize, setUiSize, wasUsingRift;
  VIEW_ANGLE = 45;
  ASPECT = state.width / state.height;
  NEAR = 0.1;
  FAR = 10000;
  $viewer = $('#viewer');
  state.camera = new THREE.PerspectiveCamera(VIEW_ANGLE, ASPECT, NEAR, FAR);

  /*
  	contained apps should stay in x: -50,50 y: 150,250 z: -50,50
   */
  state.camera.rotation.x = Math.PI / 2;
  state.camera.position.y = 0;
  state.camera.position.z = 10;
  state.camera.useQuaternion = true;
  try {
    renderer = new THREE.WebGLRenderer({
      antialias: true
    });
  } catch (_error) {
    e = _error;
    alert('This application needs WebGL enabled!');
    return false;
  }
  renderer.autoClearColor = true;
  renderer.setSize(state.width, state.height);
  $viewer.append(renderer.domElement);
  state.mobileCamera = new THREE.OrthographicCamera(0, 1, 1, 0, -30, 30);
  state.mobileCamera.position.z = 10;
  state.mobileCamera.up = new THREE.Vector3(0, 1, 0);
  state.mobileRenderer = new THREE.WebGLRenderer({
    antialias: true
  });
  state.mobileRenderer.autoClearColor = true;
  state.mobileRenderer.setSize(400, 400);
  pointLight = new THREE.PointLight(0xFFFFFF);
  pointLight.position.x = 50;
  pointLight.position.y = 50;
  pointLight.position.z = 300;
  directLight = new THREE.DirectionalLight(0xFFFFFF);
  directLight.position.x = 0;
  directLight.position.y = 0;
  directLight.position.z = 1;
  USE_TRACKER = false;
  WORLD_FACTOR = 1.0;
  OculusRift = {
    hResolution: 1280,
    vResolution: 800,
    hScreenSize: 0.14976,
    vScreenSize: 0.0936,
    interpupillaryDistance: 0.064,
    lensSeparationDistance: 0.064,
    eyeToScreenDistance: 0.041,
    distortionK: [1.0, 0.22, 0.24, 0.0],
    chromaAbParameter: [0.996, -0.004, 1.014, 0.0]
  };
  currHeading = 0;
  centerHeading = 0;
  navList = [];
  headingVector = new THREE.Vector3();
  moveVector = new THREE.Vector3();
  keyboardMoveVector = new THREE.Vector3();
  HMDRotation = new THREE.Quaternion();
  OculusRift.hResolution = state.width;
  OculusRift.vResolution = state.height;
  effect = new THREE.OculusRiftEffect(renderer, {
    HMD: OculusRift,
    worldFactor: WORLD_FACTOR
  });
  effect.setSize(state.width, state.height);
  resize = function(event) {
    state.width = window.innerWidth;
    state.height = window.innerHeight;
    setUiSize();
    ASPECT = state.width / state.height;
    OculusRift.hResolution = state.width;
    OculusRift.vResolution = state.height;
    effect.setHMD(OculusRift);
    renderer.setSize(state.width, state.height);
    return state.camera.projectionMatrix.makePerspective(VIEW_ANGLE, ASPECT, NEAR, FAR);
  };
  window.addEventListener('resize', resize, false);
  setUiSize = function() {
    var height, hwidth, width;
    width = window.innerWidth;
    hwidth = width / 2;
    return height = window.innerHeight;
  };
  projGeo = new THREE.SphereGeometry(5000, 512, 256);
  projMaterial = new THREE.MeshBasicMaterial({
    map: THREE.ImageUtils.loadTexture('static/placeholder.png'),
    side: THREE.DoubleSide
  });
  wasUsingRift = false;
  render = function() {
    var adjustedHMDQuarternion, matr, matr2, scene, tilt, tilt2;
    requestAnimationFrame(render);
    moveVector.add(keyboardMoveVector);
    if (USE_TRACKER || (state.vr != null)) {
      moveVector.x = 0;
    }
    state.BaseRotationEuler.set(0.0, util.angleRangeRad(state.BaseRotationEuler.y + moveVector.y), 0.0);
    state.BaseRotation.setFromEuler(state.BaseRotationEuler, 'YZX');
    matr = new THREE.Matrix4();
    matr.makeRotationFromQuaternion(state.BaseRotation);
    tilt = new THREE.Matrix4();
    tilt.makeRotationX(Math.PI / 2);
    matr.multiplyMatrices(tilt, matr);
    state.BaseRotation.setFromRotationMatrix(matr);
    adjustedHMDQuarternion = new THREE.Quaternion();
    adjustedHMDQuarternion.x = HMDRotation.x;
    adjustedHMDQuarternion.y = HMDRotation.y;
    adjustedHMDQuarternion.z = HMDRotation.z;
    adjustedHMDQuarternion.w = HMDRotation.w;
    matr2 = new THREE.Matrix4();
    matr2.makeRotationFromQuaternion(adjustedHMDQuarternion);
    tilt2 = new THREE.Matrix4();
    tilt2.makeRotationX(0 * Math.PI / 2);
    matr2.multiplyMatrices(tilt2, matr2);
    adjustedHMDQuarternion.setFromRotationMatrix(matr2);
    state.camera.quaternion.multiplyQuaternions(state.BaseRotation, adjustedHMDQuarternion);
    headingVector.setEulerFromQuaternion(state.camera.quaternion, 'YZX');
    currHeading = util.angleRangeDeg(THREE.Math.radToDeg(-1 * headingVector.y));
    scene = new THREE.Scene();
    if (state.front_and_back != null) {
      (function() {
        return state.front_and_back.external.drawImmersive(scene);
      })();
    } else {
      switch (state.mode) {
        case state.modes.Normal:
          if (state.front != null) {
            (function() {
              return state.front.external.drawContained(scene);
            })();
          }
          break;
        case state.modes.AppSwitch:
          state.appSwitcher.external.drawContained(scene);
      }
      if (state.back != null) {
        (function() {
          return state.back.external.drawImmersiveBackground(scene);
        })();
      }
    }
    state.drawPanel(scene, util);
    scene.add(state.camera);
    scene.add(directLight);
    if (Date.now() - state.lastUpdate < 100) {
      effect.render(scene, state.camera);
      return wasUsingRift = true;
    } else {
      HMDRotation.x = 0;
      HMDRotation.y = 0;
      HMDRotation.z = 0;
      HMDRotation.w = 1;
      if (wasUsingRift) {
        state.BaseRotationEuler.y = 0;
      }
      renderer.setViewport(0, 0, state.width, state.height);
      renderer.render(scene, state.camera);
      return wasUsingRift = false;
    }
  };
  setUiSize();
  return render();
};
